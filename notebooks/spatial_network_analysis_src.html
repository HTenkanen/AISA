

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>6. Spatial Network analysis &#8212; Introduction to Spatial Analytics  documentation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script >var togglebuttonSelector = '.toggle';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="7. Spatial Regression" href="spatial_regression.html" />
    <link rel="prev" title="5. Spatial Interpolation" href="spatial_interpolation.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    


    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar">
<a class="navbar-brand" href="../index.html">
  <img src="../_static/Intro-spatial-analytics.png" class="logo" alt="logo">
</a>



<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
    <i class="icon fas fa-search"></i>
    <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
  </form>

  <nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

    <div class="bd-toc-item active">
    



    <ul class="nav bd-sidenav">
        
        <li class="nav-item ">
            <a class="nav-link" href="../course_information.html">Course information</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../analysis_workflow.html">1. Introduction to Spatial Analytics</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="data_aquisition.html">2. Spatial data aquisition, cleaning, filtering and classification</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="point_pattern_analysis.html">3. Point pattern analysis and clustering</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="spatial_autocorrelation.html">4. Spatial autocorrelation and LISA</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="spatial_interpolation.html">5. Spatial Interpolation</a>
        </li>
        
        <li class="nav-item active">
            <a class="nav-link" href="">6. Spatial Network analysis</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="spatial_regression.html">7. Spatial Regression</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="big_data_spatial_analytics.html">8. Applying spatial analytics in the Era of Big Data</a>
        </li>
        
    </ul>

  </nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#introduction" class="nav-link">Introduction</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#tutorial" class="nav-link">Tutorial</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#what-is-a-graph" class="nav-link">What is a graph?</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#node-and-edge-attributes" class="nav-link">Node and Edge attributes</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#directed-vs-undirected-graphs" class="nav-link">Directed vs Undirected graphs</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#typical-workflow-for-spatial-network-analysis" class="nav-link">Typical workflow for spatial network analysis</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#network-analysis-by-walking-cycling" class="nav-link">Network analysis by walking / cycling</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#retrieve-data" class="nav-link">1. Retrieve data</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#modify-the-graph" class="nav-link">2. Modify the graph</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#build-graph" class="nav-link">3. Build graph</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#routing-with-networkx" class="nav-link">4. Routing with NetworkX</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#basic-logic-in-routing" class="nav-link">Basic logic in routing</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#find-the-optimal-route-between-two-locations" class="nav-link">Find the optimal route between two locations</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#find-the-nearest-nodes" class="nav-link">Find the nearest nodes</a>
        </li>
    
        <li class="nav-item toc-entry toc-h3">
            <a href="#find-the-fastest-route-by-walking-cycling" class="nav-link">Find the fastest route by walking / cycling</a>
        </li>
    
            </ul>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#visualize-the-results" class="nav-link">5. Visualize the results</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#calculate-travel-times-from-one-to-many-locations" class="nav-link">Calculate travel times from one to many locations</a><ul class="nav section-nav flex-column">
                
        <li class="nav-item toc-entry toc-h3">
            <a href="#alternative-approach-ego-graph" class="nav-link">Alternative approach - Ego graph</a>
        </li>
    
            </ul>
        </li>
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="spatial-network-analysis">
<h1>6. Spatial Network analysis<a class="headerlink" href="#spatial-network-analysis" title="Permalink to this headline">¶</a></h1>
<a class="reference external image-reference" href="https://mybinder.org/v2/gh/HTenkanen/AISA/master?urlpath=lab/tree/sources/notebooks/spatial_network_analysis.ipynb"><img alt="https://img.shields.io/badge/Interact-Run%20the%20codes%20in%20browser-orange.svg" src="https://img.shields.io/badge/Interact-Run%20the%20codes%20in%20browser-orange.svg" /></a>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><strong>Networks are everywhere</strong>. Social networks, telecommunication networks, neural networks (in our brains), and transportation networks
are all very familiar examples how the networks surround us and are very essential to our everyday life. No surprise then,
that studying complex networks has grown to be a very important topic in various fields of science including biology, medical sciences,
social science, engineering, geography and many others.</p>
<p><em>Examples of different kind of networks:</em></p>
<iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQa8mUSXktDN0-PN22ohMps6oTxfLHLjly6ewhvcAAJm37dO9NNW8BHVy4oMe8sKIorNWOZJLM5dVf7/embed?start=false&loop=false&delayms=3000" frameborder="0" width="700" height="420" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Today we will focus on <strong>spatial networks</strong> and learn different methods for analyzing
spatial networks and conduct useful queries such as finding the shortest path along a street network.</p>
<div class="admonition-learning-goals alert alert-info" id="hint">
<p class="admonition-title">Learning goals</p>
<div class="toggle docutils container">
<p>After this tutorial, you should be able to:</p>
<blockquote>
<div><ul class="simple">
<li><p>Understand typical application areas for spatial network analysis</p></li>
<li><p>Know the basic concepts and elements of a graph (network)</p></li>
<li><p>Be able to solve simple spatial network analysis problems using Python programming language</p></li>
</ul>
</div></blockquote>
</div>
</div>
<div class="admonition-additional-materials alert alert-info" id="id1">
<p class="admonition-title">Additional materials</p>
<div class="toggle docutils container">
<p><strong>Literature</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>De Smith, Goodchild, Longley et al. (2020). Geospatial Analysis - <a class="reference external" href="https://www.spatialanalysisonline.com/HTML/index.html?network_and_location_analysis.htm">Chapter 7: Network and Location Analysis</a></p></li>
</ul>
</div></blockquote>
<p><strong>Videos</strong></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/ZHr0Ch6KRSM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>
</div>
<div class="admonition-exercise-6 alert alert-info" id="id2">
<p class="admonition-title">Exercise 6</p>
<div class="toggle docutils container">
<p>In Exercise 6, you will practice how to work with OpenStreetMap data and conduct network analysis in Python.
The practical programming sessions will be organized again on Thursday where you can get help from the course assistants.</p>
<p>You can start working on your copy of Exercise 6 by <a class="reference external" href="https://classroom.github.com/a/8LP9voLx">accepting the GitHub Classroom assignment</a>.</p>
</div>
</div>
<p>Before we dive deeper to spatial networks, <strong>let’s spend a moment with the following task</strong>:</p>
<div class="admonition-discuss-with-your-neighbor-3-minutes alert alert-primary" id="important">
<p class="admonition-title">Discuss with your neighbor (3 minutes)</p>
<p><strong>TASK 1:</strong> Think practical examples where spatial network analysis algorithms are used in daily operations of the society?</p>
<blockquote>
<div><div class="toggle docutils container">
<div class="admonition-navigation alert alert-info">
<p class="admonition-title">1. Navigation</p>
<p>Show me the best route from A to B:</p>
<blockquote>
<div><ul class="simple">
<li><p>Car navigation</p></li>
<li><p>Journey planning (public transport)</p></li>
<li><p>Emergency way-finding etc.</p></li>
</ul>
</div></blockquote>
<div class="figure align-default" id="id3">
<img alt="../_images/navigator.gif" src="../_images/navigator.gif" />
<p class="caption"><span class="caption-text"><em>Source: Sygic Ltd</em> (<a class="reference external" href="https://www.sygic.com/blog/2017/introducing-new-gps-navigation-feature-real-view-navigation">2020</a>)</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="admonition-spatial-planning alert alert-info">
<p class="admonition-title">2. Spatial planning</p>
<blockquote>
<div><ul class="simple">
<li><p>Where should we locate a new service?</p></li>
<li><p>Where traffic congestion is most likely going to worsen in the future? (simulations)</p></li>
<li><p>How many people can reach this location within X minutes?</p></li>
</ul>
</div></blockquote>
<div class="figure align-default" id="id4">
<img alt="../_images/travel_time_isochrones.gif" src="../_images/travel_time_isochrones.gif" />
<p class="caption"><span class="caption-text"><em>How fast do you reach different parts of the city by different travel modes? (pink: private car, yellow: bicycle, green: public transport) Source: Topi Tjukanov</em> (<a class="reference external" href="https://tjukanov.org/accessibility-fireworks">2018</a>)</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="admonition-spatial-economics alert alert-info">
<p class="admonition-title">3. Spatial economics</p>
<blockquote>
<div><ul class="simple">
<li><p>Forecasting economic developments in the area</p></li>
<li><p>How many more customers/revenue this shop is going to get when the new metro-line opens?</p></li>
<li><p>Spatial interaction models (e.g. gravity models such as Huff’s)</p></li>
</ul>
</div></blockquote>
<div class="figure align-default" id="id5">
<img alt="../_images/Huffs_model.jpg" src="../_images/Huffs_model.jpg" />
<p class="caption"><span class="caption-text"><em>Source Ela Dramowicz</em> (<a class="reference external" href="https://www.directionsmag.com/article/3207">2015</a>)</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="tutorial">
<h2>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h2>
<p>Finding a shortest path using a specific street network is a common spatial analytics
problem that has many practical every-day applications.</p>
<p><strong>How to do network analysis in practice? What tools to use?</strong> Luckily, Python provides easy to use tools for conducting spatial network analysis.
One of the easiest ways to start is to use a library
called <a class="reference external" href="https://networkx.github.io/documentation/stable/">Networkx</a>
which is a Python module that provides a lot tools that can be used to
analyze networks on various different ways. It also contains algorithms
such as <a class="reference external" href="https://networkx.github.io/documentation/networkx-1.10/reference/generated/networkx.algorithms.shortest_paths.weighted.single_source_dijkstra.html#networkx.algorithms.shortest_paths.weighted.single_source_dijkstra">Dijkstra’s
algorithm</a>
or
<a class="reference external" href="https://networkx.github.io/documentation/networkx-1.10/reference/generated/networkx.algorithms.shortest_paths.astar.astar_path.html#networkx.algorithms.shortest_paths.astar.astar_path">A*</a>
algoritm that are commonly used to find shortest paths along
transportation network.</p>
<p>Next, we will learn how to do spatial network analysis in practice.</p>
</div>
<div class="section" id="what-is-a-graph">
<h2>What is a graph?<a class="headerlink" href="#what-is-a-graph" title="Permalink to this headline">¶</a></h2>
<p>Before continuing, it is good to understand some basic things about a
<strong>graph</strong> that is the underlying data structure used when conducting
routing.</p>
<p>Graphs are, in principle, very simple data structures, and they consists
of:</p>
<ol class="arabic simple">
<li><p><strong>nodes</strong> (e.g. intersections on a street, or a person in social
network), and</p></li>
<li><p><strong>edges</strong> (a link that connects the nodes to each other)</p></li>
</ol>
<p>A simple graph could look like this:</p>
<div class="figure align-default" id="id6">
<img alt="A simple graph." src="../_images/graph_basics.jpg" />
<p class="caption"><span class="caption-text">A simple graph.</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
<p>Here, the letters <code class="docutils literal notranslate"><span class="pre">A,</span> <span class="pre">B,</span> <span class="pre">C,</span> <span class="pre">D,</span> <span class="pre">and</span> <span class="pre">E</span></code> are nodes and the lines that
goes between them are edges/links.</p>
<div class="section" id="node-and-edge-attributes">
<h3>Node and Edge attributes<a class="headerlink" href="#node-and-edge-attributes" title="Permalink to this headline">¶</a></h3>
<p>In terms of street networks, nodes typically contain the geographical
information associated with the graph (i.e. coordinates of the
intersection). Edges typically contain much more information. They
e.g. contain information about <strong>which nodes are connected to each
other</strong>, and what is the <strong>cost</strong> to travel between the nodes
(e.g. time, distance, CO2, etc.). It is also possible to associate
geographical information to edges (if you e.g. want to show how the
roads are curved between intersections), but for basic travel time
analyses this is not needed.</p>
<p>ADD IMAGE OF GRAPH WITH COSTS.</p>
</div>
<div class="section" id="directed-vs-undirected-graphs">
<h3>Directed vs Undirected graphs<a class="headerlink" href="#directed-vs-undirected-graphs" title="Permalink to this headline">¶</a></h3>
<p>Graph can be <strong>directed</strong> or <strong>undirected</strong>, which basically determines
whether the roads can be travelled to any direction or whether the
travel direction is restricted to certain direction (e.g. a
one-way-street).</p>
<p>In <strong>undirected</strong> graph, it is possible to travel in both directions
between nodes (e.g. from <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">--&gt;</span> <span class="pre">B</span></code> and from <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">--&gt;</span> <span class="pre">A</span></code>). Undirected
graphs are typically used e.g. with walking and cycling as with those
travel modes it is typically possible to travel the same street in any
direction you like.</p>
<p>ADD IMAGE OF DIRECTED GRAPH.</p>
<p>If the graph is <strong>directed</strong>, it means that you should have a separate
edge for each direction. If you for example have a graph with only an
edge that goes from <code class="docutils literal notranslate"><span class="pre">D</span></code> to <code class="docutils literal notranslate"><span class="pre">E</span></code>, you can travel to node <code class="docutils literal notranslate"><span class="pre">E</span></code> from
<code class="docutils literal notranslate"><span class="pre">D</span></code> but you cannot travel back. In directed graphs, <strong>you need to have
a separate edge for each travel direction</strong>. Fundamentally this means
that for a bi-directional road, you should have edges in your data
(i.e. two separate rows), such as:</p>
<table class="table">
<colgroup>
<col style="width: 16%" />
<col style="width: 20%" />
<col style="width: 16%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>edge_id</p></th>
<th class="head"><p>from_node</p></th>
<th class="head"><p>to_node</p></th>
<th class="head"><p>description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>D</p></td>
<td><p>E</p></td>
<td><p><em>edge for direction 1</em></p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>E</p></td>
<td><p>D</p></td>
<td><p><em>edge for direction 2</em></p></td>
</tr>
</tbody>
</table>
<div class="admonition-task-2-vote alert alert-info" id="note">
<p class="admonition-title">TASK 2 - Vote!</p>
<p>The following routes are examples of paths with costs along the network. Which one is faster? Choose A or B.
(press <strong>+</strong> to open the questionnaire)</p>
<blockquote>
<div><div class="toggle docutils container">
<div class="admonition-questions-open-in-full-screen-if-difficult-to-see alert alert-info">
<p class="admonition-title">Questions (open in full screen if difficult to see)</p>
<iframe src="https://docs.google.com/presentation/d/e/2PACX-1vQa8mUSXktDN0-PN22ohMps6oTxfLHLjly6ewhvcAAJm37dO9NNW8BHVy4oMe8sKIorNWOZJLM5dVf7/embed?start=false&loop=false&delayms=3000" frameborder="0" width="550" height="350" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe></div>
</div>
</div></blockquote>
</div>
<p>Next, we will continue, and see how to conduct shortest path analysis by walking/cycling using Python.</p>
</div>
</div>
<div class="section" id="typical-workflow-for-spatial-network-analysis">
<h2>Typical workflow for spatial network analysis<a class="headerlink" href="#typical-workflow-for-spatial-network-analysis" title="Permalink to this headline">¶</a></h2>
<p>If you want to conduct network analysis (in any programming language)
there are a few basic steps that needs to be done before you can start
routing (<strong>remember the workflow that we learned during the first lesson</strong>).</p>
<p>These steps are:</p>
<ol class="arabic simple">
<li><p><strong>Retrieve data</strong> (such as street network from OSM or Digiroad +
possibly transit data if routing with PT).</p></li>
<li><p>(Possibly modify the network by applying custom edge weights
considering e.g. traffic conditions for car).</p></li>
<li><p><strong>Build a routable graph</strong> for the routing tool that you are using
(e.g. NetworkX, Igraph or OpenTripPlanner).</p></li>
<li><p><strong>Conduct network analysis</strong> (such as shortest path analysis) with
the routing tool of your choice.</p></li>
<li><p><strong>Visualize the results</strong> (e.g. the shortest paths on the map, or isochrones)</p></li>
</ol>
</div>
<div class="section" id="network-analysis-by-walking-cycling">
<h2>Network analysis by walking / cycling<a class="headerlink" href="#network-analysis-by-walking-cycling" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="retrieve-data">
<h2>1. Retrieve data<a class="headerlink" href="#retrieve-data" title="Permalink to this headline">¶</a></h2>
<p>As a first step, we need to obtain data for routing.
<a class="reference external" href="https://github.com/gboeing/osmnx">OSMnx</a> library makes it really
easy to retrieve routable networks from OpenStreetMap with different
transport modes (walking, cycling and driving). Osmnx also combines some
functionalities from <code class="docutils literal notranslate"><span class="pre">networkx</span></code> module to make it straightforward to
conduct routing along OpenStreetMap data.</p>
<ul class="simple">
<li><p>Let’s first download the OSM data from Kamppi that are walkable. In
OSMnx, we can use a function called <code class="docutils literal notranslate"><span class="pre">.graph_from_place()</span></code> which
retrieves data from OpenStreetMap. It is possible to specify what
kind of roads should be retrieved from OSM with <code class="docutils literal notranslate"><span class="pre">network_type</span></code>
-parameter.</p></li>
</ul>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">osmnx</span> <span class="k">as</span> <span class="nn">ox</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span>

<span class="c1"># The place where you want to retrieve the data</span>
<span class="c1"># OSMnx uses Nominatim/OverPass API to retrieve the data</span>
<span class="c1"># You can check that your place name is valid from: https://nominatim.openstreetmap.org/</span>
<span class="n">place</span> <span class="o">=</span> <span class="s2">&quot;Kamppi, Helsinki, Finland&quot;</span>

<span class="c1"># Retrieve pedestrian data</span>
<span class="n">kamppi</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">gdf_from_place</span><span class="p">(</span><span class="n">place</span><span class="p">)</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">graph_from_place</span><span class="p">(</span><span class="n">place</span><span class="p">,</span> <span class="n">network_type</span><span class="o">=</span><span class="s1">&#39;walk&#39;</span><span class="p">)</span>

<span class="c1"># What did we retrieve?</span>
<span class="n">G</span>
</pre></div>
</div>
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>&lt;networkx.classes.multidigraph.MultiDiGraph at 0x7fc523ae6ca0&gt;
</pre></div>
</div>
</div>
<p>Okay, so as we can see the <code class="docutils literal notranslate"><span class="pre">OSMnx</span></code> library fetched some data and
returned us a <code class="docutils literal notranslate"><span class="pre">MultiDiGraph</span></code> object.</p>
<p>Let’s see what the data looks like:</p>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">plot_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../_images/spatial_network_analysis_src_1_0.png" src="../_images/spatial_network_analysis_src_1_0.png" />
</div>
<p>As we can see, now we have fetched walkable streets from Kamppi. In the
figure, the lines are streets and all the nodes are represented with
light blue color.</p>
<p><strong>How does the actual data look like?</strong></p>
<p>There are a couple of ways to access the edge and node attributes. The
easier way is to use an OSMnx function <code class="docutils literal notranslate"><span class="pre">graph_to_gdfs()</span></code> that returns
the nodes and edges as GeoDataFrames. The other option to access the
data is via the graph itself by looping through nodes and edges as
follow: - <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">node_id,</span> <span class="pre">node</span> <span class="pre">in</span> <span class="pre">G.nodes(data=True)</span></code> -
<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">fr,</span> <span class="pre">to,</span> <span class="pre">edge</span> <span class="pre">in</span> <span class="pre">G.edges(data=True)</span></code></p>
<p>Often you want to manipulate nodes and edges somehow. Hence, often it is
useful to fetch the data into GeoDataFrames:</p>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">graph_to_gdfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># you can flag whether you want to e.g. exclude nodes</span>
</pre></div>
</div>
</div>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the first rows of the nodes</span>
<span class="n">nodes</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>y</th>
      <th>x</th>
      <th>osmid</th>
      <th>highway</th>
      <th>ref</th>
      <th>geometry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>3216400385</th>
      <td>60.167552</td>
      <td>24.934005</td>
      <td>3216400385</td>
      <td>turning_circle</td>
      <td>NaN</td>
      <td>POINT (24.93400 60.16755)</td>
    </tr>
    <tr>
      <th>1372233731</th>
      <td>60.162290</td>
      <td>24.929274</td>
      <td>1372233731</td>
      <td>crossing</td>
      <td>NaN</td>
      <td>POINT (24.92927 60.16229)</td>
    </tr>
    <tr>
      <th>1005744134</th>
      <td>60.161622</td>
      <td>24.924423</td>
      <td>1005744134</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>POINT (24.92442 60.16162)</td>
    </tr>
    <tr>
      <th>319885318</th>
      <td>60.165062</td>
      <td>24.925501</td>
      <td>319885318</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>POINT (24.92550 60.16506)</td>
    </tr>
    <tr>
      <th>3216400394</th>
      <td>60.167662</td>
      <td>24.933920</td>
      <td>3216400394</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>POINT (24.93392 60.16766)</td>
    </tr>
  </tbody>
</table>
</div></div></div>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># First rows of the edges</span>
<span class="n">edges</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>u</th>
      <th>v</th>
      <th>key</th>
      <th>osmid</th>
      <th>name</th>
      <th>highway</th>
      <th>maxspeed</th>
      <th>oneway</th>
      <th>length</th>
      <th>geometry</th>
      <th>lanes</th>
      <th>service</th>
      <th>tunnel</th>
      <th>access</th>
      <th>bridge</th>
      <th>junction</th>
      <th>ref</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>3216400385</td>
      <td>301360890</td>
      <td>0</td>
      <td>15240373</td>
      <td>Kansakoulukuja</td>
      <td>residential</td>
      <td>30</td>
      <td>False</td>
      <td>13.177</td>
      <td>LINESTRING (24.93400 60.16755, 24.93393 60.167...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1372233731</td>
      <td>298367080</td>
      <td>0</td>
      <td>86533507</td>
      <td>NaN</td>
      <td>footway</td>
      <td>NaN</td>
      <td>False</td>
      <td>6.925</td>
      <td>LINESTRING (24.92927 60.16229, 24.92917 60.16225)</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1372233731</td>
      <td>292859610</td>
      <td>0</td>
      <td>15103120</td>
      <td>NaN</td>
      <td>primary_link</td>
      <td>30</td>
      <td>False</td>
      <td>33.874</td>
      <td>LINESTRING (24.92927 60.16229, 24.92930 60.162...</td>
      <td>2</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1372233731</td>
      <td>2390968896</td>
      <td>0</td>
      <td>[86533504, 23025219]</td>
      <td>Hietalahdenkatu</td>
      <td>primary</td>
      <td>30</td>
      <td>False</td>
      <td>68.200</td>
      <td>LINESTRING (24.92927 60.16229, 24.92868 60.162...</td>
      <td>[2, 3]</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1372233731</td>
      <td>4430643601</td>
      <td>0</td>
      <td>[154412960, 86533507]</td>
      <td>NaN</td>
      <td>footway</td>
      <td>NaN</td>
      <td>False</td>
      <td>12.489</td>
      <td>LINESTRING (24.92927 60.16229, 24.92941 60.162...</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div></div></div>
<p>As we can see from this edge-table, we have a lot of information. For
routing purposes, the most useful attributes are <code class="docutils literal notranslate"><span class="pre">length</span></code> (in meters)
and <code class="docutils literal notranslate"><span class="pre">maxspeed</span></code> (for car routing) which we can use to calculate travel
times.</p>
</div>
<div class="section" id="modify-the-graph">
<h2>2. Modify the graph<a class="headerlink" href="#modify-the-graph" title="Permalink to this headline">¶</a></h2>
<p>Let’s next modify the data in our graph, so that we can conduct the
shortest path search based on travel time.</p>
<p>In this case, we specify that the <strong>walking speed is a static 4.5 kmph</strong>
and <strong>cycling speed is 19 kmph</strong>. We will calculate the cost of travel
(time) for each road segment (i.e. edge) into a new column <code class="docutils literal notranslate"><span class="pre">walk_t</span></code>
that we can later use as a weight variable in routing (also known as
impedance or cost).</p>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Calculate the time (in seconds) it takes to walk through road segments</span>
<span class="n">walk_speed</span> <span class="o">=</span> <span class="mf">4.5</span>  <span class="c1"># kmph</span>
<span class="n">edges</span><span class="p">[</span><span class="s1">&#39;walk_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span> <span class="n">edges</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">walk_speed</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Do the same for cycling</span>
<span class="n">cycling_speed</span> <span class="o">=</span> <span class="mi">19</span>  <span class="c1"># kmph</span>
<span class="n">edges</span><span class="p">[</span><span class="s1">&#39;bike_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span> <span class="n">edges</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">cycling_speed</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Let&#39;s check what we got</span>
<span class="n">edges</span><span class="p">[[</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="s1">&#39;walk_t&#39;</span><span class="p">,</span> <span class="s1">&#39;bike_t&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>length</th>
      <th>walk_t</th>
      <th>bike_t</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>13.177</td>
      <td>10.5</td>
      <td>2.5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>6.925</td>
      <td>5.5</td>
      <td>1.3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>33.874</td>
      <td>27.1</td>
      <td>6.4</td>
    </tr>
    <tr>
      <th>3</th>
      <td>68.200</td>
      <td>54.6</td>
      <td>12.9</td>
    </tr>
    <tr>
      <th>4</th>
      <td>12.489</td>
      <td>10.0</td>
      <td>2.4</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<div class="section" id="build-graph">
<h2>3. Build graph<a class="headerlink" href="#build-graph" title="Permalink to this headline">¶</a></h2>
<p>Now as we have calculated the travel time for our edges. We still need
to convert our nodes and edges back to a NetworkX graph, so that we can
start using it for routing. When using OSM data fetched with OSMnx this
can be done easily with function <code class="docutils literal notranslate"><span class="pre">ox.gdfs_to_graph()</span></code>. Notice that
this <strong>only works when using OSMnx library</strong>, we will later see in
detail how the graphs are built from scratch which enables you to
customize them.</p>
<ul class="simple">
<li><p>Let’s build the graph with OSMnx:</p></li>
</ul>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">gdfs_to_graph</span><span class="p">(</span><span class="n">gdf_nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span> <span class="n">gdf_edges</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span>
<span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>networkx.classes.multidigraph.MultiDiGraph
</pre></div>
</div>
</div>
<p>Okay, now we have converted our data back into a NetworkX graph. Let’s
ensure that our new edge attribute really exists:</p>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check only the first row from edges</span>
<span class="k">for</span> <span class="n">fr</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="k">break</span>
</pre></div>
</div>
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>{&#39;osmid&#39;: 15240373, &#39;name&#39;: &#39;Kansakoulukuja&#39;, &#39;highway&#39;: &#39;residential&#39;, &#39;maxspeed&#39;: &#39;30&#39;, &#39;oneway&#39;: False, &#39;length&#39;: 13.177, &#39;geometry&#39;: &lt;shapely.geometry.linestring.LineString object at 0x7fc5211e96d0&gt;, &#39;walk_t&#39;: 10.5, &#39;bike_t&#39;: 2.5}
</pre></div>
</div>
</div>
<p>Great, as we can see now we have a new edge attribute in our graph that
we can use for routing.</p>
</div>
<div class="section" id="routing-with-networkx">
<h2>4. Routing with NetworkX<a class="headerlink" href="#routing-with-networkx" title="Permalink to this headline">¶</a></h2>
<p>Now we have everything we need to start routing with NetworkX (by
walking and cycling). But first, let’s again go through some basics
about routing.</p>
<div class="section" id="basic-logic-in-routing">
<h3>Basic logic in routing<a class="headerlink" href="#basic-logic-in-routing" title="Permalink to this headline">¶</a></h3>
<p>Most (if not all) routing algorithms work more or less in a similar
manner. The basic steps for finding an optimal route from A to B, is to:
1. Find the nearest node for origin location * (+ get info about its
node-id and distance between origin and node) 2. Find the nearest node
for destination location * (+ get info about its node-id and distance
between origin and node) 3. Use a routing algorithm to find the shortest
path between A and B 4. Retrieve edge attributes for the given route(s)
and summarize them (can be distance, time, CO2, or whatever)</p>
<p>* in more advanced implementations you might search for the closest
edge</p>
<p>This same logic should be applied always when searching for an optimal
route between a single origin to a single destination, or when
calculating one-to-many -type of routing queries (producing e.g. travel
time matrices).</p>
</div>
<div class="section" id="find-the-optimal-route-between-two-locations">
<h3>Find the optimal route between two locations<a class="headerlink" href="#find-the-optimal-route-between-two-locations" title="Permalink to this headline">¶</a></h3>
<p>Next, we will learn how to find the shortest path between two locations
using
<a class="reference external" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra’s</a>
algorithm.</p>
<p>First, let’s find the closest nodes for two locations that are located
in the area. OSMnx provides a handly function for geocoding an address
<code class="docutils literal notranslate"><span class="pre">ox.geocode()</span></code>. We can use that to retrieve the x and y coordinates of
our origin and destination.</p>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># OSM data is in WGS84 so typically we need to use lat/lon coordinates when searching for the closest node</span>

<span class="c1"># Origin</span>
<span class="n">orig_address</span> <span class="o">=</span> <span class="s2">&quot;Kalevankatu 16, Helsinki&quot;</span>
<span class="n">orig_y</span><span class="p">,</span> <span class="n">orig_x</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">geocode</span><span class="p">(</span><span class="n">orig_address</span><span class="p">)</span>  <span class="c1"># notice the coordinate order (y, x)!</span>

<span class="c1"># Destination</span>
<span class="n">dest_address</span> <span class="o">=</span> <span class="s2">&quot;Ruoholahdenkatu 24, Helsinki&quot;</span>
<span class="n">dest_y</span><span class="p">,</span> <span class="n">dest_x</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">geocode</span><span class="p">(</span><span class="n">dest_address</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Origin coords:&quot;</span><span class="p">,</span> <span class="n">orig_x</span><span class="p">,</span> <span class="n">orig_y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Destination coords:&quot;</span><span class="p">,</span> <span class="n">dest_x</span><span class="p">,</span> <span class="n">dest_y</span><span class="p">)</span>
</pre></div>
</div>
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Origin coords: 24.936245 60.1665678
Destination coords: 24.9246625 60.1641351
</pre></div>
</div>
</div>
<p>Okay, now we have coordinates for our origin and destination.</p>
</div>
<div class="section" id="find-the-nearest-nodes">
<h3>Find the nearest nodes<a class="headerlink" href="#find-the-nearest-nodes" title="Permalink to this headline">¶</a></h3>
<p>Next, we need to find the closest nodes from the graph for both of our
locations. For calculating the closest point we use here <code class="docutils literal notranslate"><span class="pre">'haversine'</span></code>
formula to get the distance in meters (with <code class="docutils literal notranslate"><span class="pre">return_dist=True</span></code>).</p>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 1. Find the closest nodes for origin and destination</span>
<span class="n">orig_node_id</span><span class="p">,</span> <span class="n">dist_to_orig</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">get_nearest_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="p">(</span><span class="n">orig_y</span><span class="p">,</span> <span class="n">orig_x</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;haversine&#39;</span><span class="p">,</span> <span class="n">return_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">dest_node_id</span><span class="p">,</span> <span class="n">dist_to_dest</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">get_nearest_node</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="p">(</span><span class="n">dest_y</span><span class="p">,</span> <span class="n">dest_x</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;haversine&#39;</span><span class="p">,</span> <span class="n">return_dist</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Origin node-id:&quot;</span><span class="p">,</span> <span class="n">orig_node_id</span><span class="p">,</span> <span class="s2">&quot;and distance:&quot;</span><span class="p">,</span> <span class="n">dist_to_orig</span><span class="p">,</span> <span class="s2">&quot;meters.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Destination node-id:&quot;</span><span class="p">,</span> <span class="n">dest_node_id</span><span class="p">,</span> <span class="s2">&quot;and distance:&quot;</span><span class="p">,</span> <span class="n">dist_to_dest</span><span class="p">,</span> <span class="s2">&quot;meters.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Origin node-id: 298372995 and distance: 43.872491349361404 meters.
Destination node-id: 5809140035 and distance: 48.867235001413256 meters.
</pre></div>
</div>
</div>
<p>Now we are ready to start the actual routing with NetworkX.</p>
</div>
<div class="section" id="find-the-fastest-route-by-walking-cycling">
<h3>Find the fastest route by walking / cycling<a class="headerlink" href="#find-the-fastest-route-by-walking-cycling" title="Permalink to this headline">¶</a></h3>
<p>Now we can do the routing and find the shortest path between the origin
and target locations by using the <code class="docutils literal notranslate"><span class="pre">dijkstra_path()</span></code> function of
NetworkX. For getting only the cumulative cost of the trip, we can
directly use a function <code class="docutils literal notranslate"><span class="pre">dijkstra_path_length()</span></code> that returns the
travel time without the actual path.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">weight</span></code> -parameter we can specify the attribute that we want to
use as cost/impedance. We have now three possible weight attributes
available: <code class="docutils literal notranslate"><span class="pre">'length'</span></code>, <code class="docutils literal notranslate"><span class="pre">'walk_t'</span></code> and <code class="docutils literal notranslate"><span class="pre">'bike_t'</span></code>.</p>
<ul class="simple">
<li><p>Let’s first calculate the routes between locations by walking and
cycling, and also retrieve the travel times</p></li>
</ul>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="c1"># Calculate the paths by walking and cycling</span>
<span class="n">walk_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">dest_node_id</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;walk_t&#39;</span><span class="p">)</span>
<span class="n">bike_path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">dest_node_id</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bike_t&#39;</span><span class="p">)</span>

<span class="c1"># Get also the actual travel times (summarize)</span>
<span class="n">walk_t</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">dest_node_id</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;walk_t&#39;</span><span class="p">)</span>
<span class="n">bike_t</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">dest_node_id</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;bike_t&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Okay, that was it! Let’s now see what we got as results by visualizing
the results.</p>
</div>
</div>
<div class="section" id="visualize-the-results">
<h2>5. Visualize the results<a class="headerlink" href="#visualize-the-results" title="Permalink to this headline">¶</a></h2>
<p>For visualization purposes, we can use a handy function again from OSMnx
called <code class="docutils literal notranslate"><span class="pre">ox.plot_graph_route()</span></code> (for static) or
<code class="docutils literal notranslate"><span class="pre">ox.plot_route_folium()</span></code> (for interactive plot).</p>
<ul class="simple">
<li><p>Let’s first make static maps</p></li>
</ul>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Walking</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">plot_graph_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">walk_path</span><span class="p">)</span>

<span class="c1"># Add the travel time as title</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Walk time </span><span class="si">{t: .1f}</span><span class="s2"> minutes.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">walk_t</span><span class="o">/</span><span class="mi">60</span><span class="p">))</span>
</pre></div>
</div>
<img alt="../_images/spatial_network_analysis_src_11_0.png" src="../_images/spatial_network_analysis_src_11_0.png" />
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>Text(0.5, 0, &#39;Walk time  12.0 minutes.&#39;)
</pre></div>
</div>
</div>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Cycling</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">plot_graph_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">bike_path</span><span class="p">)</span>

<span class="c1"># Add the travel time as title</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Cycling time </span><span class="si">{t: .1f}</span><span class="s2"> minutes.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">bike_t</span><span class="o">/</span><span class="mi">60</span><span class="p">))</span>
</pre></div>
</div>
<img alt="../_images/spatial_network_analysis_src_12_0.png" src="../_images/spatial_network_analysis_src_12_0.png" />
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>Text(0.5, 0, &#39;Cycling time  2.8 minutes.&#39;)
</pre></div>
</div>
</div>
<p>Great! Now we have successfully found the optimal route between our
origin and destination and we also have estimates about the travel time
that it takes to travel between the locations by walking and cycling. As
we can see, the route for both travel modes is exactly the same which is
natural, as the only thing that changed here was the constant travel
speed.</p>
<ul class="simple">
<li><p>Let’s still finally see an example how you can plot a nice
interactive map out of our results with OSMnx:</p></li>
</ul>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ox</span><span class="o">.</span><span class="n">plot_route_folium</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">walk_path</span><span class="p">,</span> <span class="n">popup_attribute</span><span class="o">=</span><span class="s1">&#39;walk_t&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="output text_html"><div style="width:100%;"><div style="position:relative;width:100%;height:0;padding-bottom:60%;"><span style="color:#565656">Make this Notebook Trusted to load map: File -> Trust Notebook</span><iframe src="about:blank" style="position:absolute;width:100%;height:100%;left:0;top:0;border:none !important;" data-html=PCFET0NUWVBFIGh0bWw+CjxoZWFkPiAgICAKICAgIDxtZXRhIGh0dHAtZXF1aXY9ImNvbnRlbnQtdHlwZSIgY29udGVudD0idGV4dC9odG1sOyBjaGFyc2V0PVVURi04IiAvPgogICAgCiAgICAgICAgPHNjcmlwdD4KICAgICAgICAgICAgTF9OT19UT1VDSCA9IGZhbHNlOwogICAgICAgICAgICBMX0RJU0FCTEVfM0QgPSBmYWxzZTsKICAgICAgICA8L3NjcmlwdD4KICAgIAogICAgPHNjcmlwdCBzcmM9Imh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbGVhZmxldEAxLjYuMC9kaXN0L2xlYWZsZXQuanMiPjwvc2NyaXB0PgogICAgPHNjcmlwdCBzcmM9Imh0dHBzOi8vY29kZS5qcXVlcnkuY29tL2pxdWVyeS0xLjEyLjQubWluLmpzIj48L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2Jvb3RzdHJhcC8zLjIuMC9qcy9ib290c3RyYXAubWluLmpzIj48L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9MZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy8yLjAuMi9sZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy5qcyI+PC9zY3JpcHQ+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vbGVhZmxldEAxLjYuMC9kaXN0L2xlYWZsZXQuY3NzIi8+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vYm9vdHN0cmFwLzMuMi4wL2Nzcy9ib290c3RyYXAubWluLmNzcyIvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2Jvb3RzdHJhcC8zLjIuMC9jc3MvYm9vdHN0cmFwLXRoZW1lLm1pbi5jc3MiLz4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9mb250LWF3ZXNvbWUvNC42LjMvY3NzL2ZvbnQtYXdlc29tZS5taW4uY3NzIi8+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vY2RuanMuY2xvdWRmbGFyZS5jb20vYWpheC9saWJzL0xlYWZsZXQuYXdlc29tZS1tYXJrZXJzLzIuMC4yL2xlYWZsZXQuYXdlc29tZS1tYXJrZXJzLmNzcyIvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL3Jhd2Nkbi5naXRoYWNrLmNvbS9weXRob24tdmlzdWFsaXphdGlvbi9mb2xpdW0vbWFzdGVyL2ZvbGl1bS90ZW1wbGF0ZXMvbGVhZmxldC5hd2Vzb21lLnJvdGF0ZS5jc3MiLz4KICAgIDxzdHlsZT5odG1sLCBib2R5IHt3aWR0aDogMTAwJTtoZWlnaHQ6IDEwMCU7bWFyZ2luOiAwO3BhZGRpbmc6IDA7fTwvc3R5bGU+CiAgICA8c3R5bGU+I21hcCB7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7Ym90dG9tOjA7cmlnaHQ6MDtsZWZ0OjA7fTwvc3R5bGU+CiAgICAKICAgICAgICAgICAgPG1ldGEgbmFtZT0idmlld3BvcnQiIGNvbnRlbnQ9IndpZHRoPWRldmljZS13aWR0aCwKICAgICAgICAgICAgICAgIGluaXRpYWwtc2NhbGU9MS4wLCBtYXhpbXVtLXNjYWxlPTEuMCwgdXNlci1zY2FsYWJsZT1ubyIgLz4KICAgICAgICAgICAgPHN0eWxlPgogICAgICAgICAgICAgICAgI21hcF8wZmJjMWI3NjE3OTQ0ZDQ1YjY1YzliOTA2ODNkNDRiMSB7CiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAuMCU7CiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAuMCU7CiAgICAgICAgICAgICAgICAgICAgbGVmdDogMC4wJTsKICAgICAgICAgICAgICAgICAgICB0b3A6IDAuMCU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIDwvc3R5bGU+CiAgICAgICAgCjwvaGVhZD4KPGJvZHk+ICAgIAogICAgCiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImZvbGl1bS1tYXAiIGlkPSJtYXBfMGZiYzFiNzYxNzk0NGQ0NWI2NWM5YjkwNjgzZDQ0YjEiID48L2Rpdj4KICAgICAgICAKPC9ib2R5Pgo8c2NyaXB0PiAgICAKICAgIAogICAgICAgICAgICB2YXIgbWFwXzBmYmMxYjc2MTc5NDRkNDViNjVjOWI5MDY4M2Q0NGIxID0gTC5tYXAoCiAgICAgICAgICAgICAgICAibWFwXzBmYmMxYjc2MTc5NDRkNDViNjVjOWI5MDY4M2Q0NGIxIiwKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBjZW50ZXI6IFs2MC4xNjUyOTI5ODI5OTQ2ODYsIDI0LjkzMDM5MzI3Nzk1NTE3Ml0sCiAgICAgICAgICAgICAgICAgICAgY3JzOiBMLkNSUy5FUFNHMzg1NywKICAgICAgICAgICAgICAgICAgICB6b29tOiAxLAogICAgICAgICAgICAgICAgICAgIHpvb21Db250cm9sOiB0cnVlLAogICAgICAgICAgICAgICAgICAgIHByZWZlckNhbnZhczogZmFsc2UsCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICk7CgogICAgICAgICAgICAKCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHRpbGVfbGF5ZXJfNWU4YjRhZWU1ZWQ0NDM4MDljMTlhMzQxNGQ3YTJlNDcgPSBMLnRpbGVMYXllcigKICAgICAgICAgICAgICAgICJodHRwczovL2NhcnRvZGItYmFzZW1hcHMte3N9Lmdsb2JhbC5zc2wuZmFzdGx5Lm5ldC9saWdodF9hbGwve3p9L3t4fS97eX0ucG5nIiwKICAgICAgICAgICAgICAgIHsiYXR0cmlidXRpb24iOiAiXHUwMDI2Y29weTsgXHUwMDNjYSBocmVmPVwiaHR0cDovL3d3dy5vcGVuc3RyZWV0bWFwLm9yZy9jb3B5cmlnaHRcIlx1MDAzZU9wZW5TdHJlZXRNYXBcdTAwM2MvYVx1MDAzZSBjb250cmlidXRvcnMgXHUwMDI2Y29weTsgXHUwMDNjYSBocmVmPVwiaHR0cDovL2NhcnRvZGIuY29tL2F0dHJpYnV0aW9uc1wiXHUwMDNlQ2FydG9EQlx1MDAzYy9hXHUwMDNlLCBDYXJ0b0RCIFx1MDAzY2EgaHJlZiA9XCJodHRwOi8vY2FydG9kYi5jb20vYXR0cmlidXRpb25zXCJcdTAwM2VhdHRyaWJ1dGlvbnNcdTAwM2MvYVx1MDAzZSIsICJkZXRlY3RSZXRpbmEiOiBmYWxzZSwgIm1heE5hdGl2ZVpvb20iOiAxOCwgIm1heFpvb20iOiAxOCwgIm1pblpvb20iOiAwLCAibm9XcmFwIjogZmFsc2UsICJvcGFjaXR5IjogMSwgInN1YmRvbWFpbnMiOiAiYWJjIiwgInRtcyI6IGZhbHNlfQogICAgICAgICAgICApLmFkZFRvKG1hcF8wZmJjMWI3NjE3OTQ0ZDQ1YjY1YzliOTA2ODNkNDRiMSk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvbHlfbGluZV81Y2NmMjc1ZTI3Mjg0ZWQ1YmZiZTZlZTQ4OWMyMjc2ZSA9IEwucG9seWxpbmUoCiAgICAgICAgICAgICAgICBbWzYwLjE2Njg0NjIsIDI0LjkzNjgwN10sIFs2MC4xNjY4ODY3LCAyNC45MzY3NTM1XV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiI2NjMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogZmFsc2UsICJmaWxsQ29sb3IiOiAiI2NjMDAwMCIsICJmaWxsT3BhY2l0eSI6IDAuMiwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJub0NsaXAiOiBmYWxzZSwgIm9wYWNpdHkiOiAxLCAic21vb3RoRmFjdG9yIjogMS4wLCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDV9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzBmYmMxYjc2MTc5NDRkNDViNjVjOWI5MDY4M2Q0NGIxKTsKICAgICAgICAKICAgIAogICAgICAgIHZhciBwb3B1cF9iZWEwZmExN2I1N2E0MmUwOGI1NGVmNGQzNTYzZGJkOSA9IEwucG9wdXAoeyJtYXhXaWR0aCI6ICIxMDAlIn0pOwoKICAgICAgICAKICAgICAgICAgICAgdmFyIGh0bWxfZWM2YTVmMzVmYzMzNDE0MDk2YTEyOGJhYTEyZTdiN2UgPSAkKGA8ZGl2IGlkPSJodG1sX2VjNmE1ZjM1ZmMzMzQxNDA5NmExMjhiYWExMmU3YjdlIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40LjM8L2Rpdj5gKVswXTsKICAgICAgICAgICAgcG9wdXBfYmVhMGZhMTdiNTdhNDJlMDhiNTRlZjRkMzU2M2RiZDkuc2V0Q29udGVudChodG1sX2VjNmE1ZjM1ZmMzMzQxNDA5NmExMjhiYWExMmU3YjdlKTsKICAgICAgICAKCiAgICAgICAgcG9seV9saW5lXzVjY2YyNzVlMjcyODRlZDViZmJlNmVlNDg5YzIyNzZlLmJpbmRQb3B1cChwb3B1cF9iZWEwZmExN2I1N2E0MmUwOGI1NGVmNGQzNTYzZGJkOSkKICAgICAgICA7CgogICAgICAgIAogICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvbHlfbGluZV83ZGYyNzcwMjEyMDk0M2YxOGRjOWNjNTFjN2FhNzFkYiA9IEwucG9seWxpbmUoCiAgICAgICAgICAgICAgICBbWzYwLjE2Njg4NjcsIDI0LjkzNjc1MzVdLCBbNjAuMTY2MzY5MSwgMjQuOTM1MjQ3MV0sIFs2MC4xNjYzMTE1LCAyNC45MzUwNzkzXV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiI2NjMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogZmFsc2UsICJmaWxsQ29sb3IiOiAiI2NjMDAwMCIsICJmaWxsT3BhY2l0eSI6IDAuMiwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJub0NsaXAiOiBmYWxzZSwgIm9wYWNpdHkiOiAxLCAic21vb3RoRmFjdG9yIjogMS4wLCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDV9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzBmYmMxYjc2MTc5NDRkNDViNjVjOWI5MDY4M2Q0NGIxKTsKICAgICAgICAKICAgIAogICAgICAgIHZhciBwb3B1cF83N2ZjNDJhOTY5ZWY0Yzc4OTFlYjUyMjk0MGZkN2I3NCA9IEwucG9wdXAoeyJtYXhXaWR0aCI6ICIxMDAlIn0pOwoKICAgICAgICAKICAgICAgICAgICAgdmFyIGh0bWxfZTY1YjJiZWVlNzY3NDA3Mjk0MGNiZGNlY2Y5ZmIyZGEgPSAkKGA8ZGl2IGlkPSJodG1sX2U2NWIyYmVlZTc2NzQwNzI5NDBjYmRjZWNmOWZiMmRhIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij45MC4wPC9kaXY+YClbMF07CiAgICAgICAgICAgIHBvcHVwXzc3ZmM0MmE5NjllZjRjNzg5MWViNTIyOTQwZmQ3Yjc0LnNldENvbnRlbnQoaHRtbF9lNjViMmJlZWU3Njc0MDcyOTQwY2JkY2VjZjlmYjJkYSk7CiAgICAgICAgCgogICAgICAgIHBvbHlfbGluZV83ZGYyNzcwMjEyMDk0M2YxOGRjOWNjNTFjN2FhNzFkYi5iaW5kUG9wdXAocG9wdXBfNzdmYzQyYTk2OWVmNGM3ODkxZWI1MjI5NDBmZDdiNzQpCiAgICAgICAgOwoKICAgICAgICAKICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb2x5X2xpbmVfOTUwYjU4OTU4MTk0NGJmMjlkMTFiZjFhNDViYjljN2QgPSBMLnBvbHlsaW5lKAogICAgICAgICAgICAgICAgW1s2MC4xNjYzMTE1LCAyNC45MzUwNzkzXSwgWzYwLjE2NjIzMzcsIDI0LjkzNDg1MzFdLCBbNjAuMTY2MTYxNiwgMjQuOTM0NjQzM10sIFs2MC4xNjYxNDc0LCAyNC45MzQ2MDE4XV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiI2NjMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogZmFsc2UsICJmaWxsQ29sb3IiOiAiI2NjMDAwMCIsICJmaWxsT3BhY2l0eSI6IDAuMiwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJub0NsaXAiOiBmYWxzZSwgIm9wYWNpdHkiOiAxLCAic21vb3RoRmFjdG9yIjogMS4wLCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDV9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzBmYmMxYjc2MTc5NDRkNDViNjVjOWI5MDY4M2Q0NGIxKTsKICAgICAgICAKICAgIAogICAgICAgIHZhciBwb3B1cF85NWUxZjQyNzU4Yzg0YzBjYTA1ZjYzMjhiMDg0MGRkYiA9IEwucG9wdXAoeyJtYXhXaWR0aCI6ICIxMDAlIn0pOwoKICAgICAgICAKICAgICAgICAgICAgdmFyIGh0bWxfOTJkYTBkZWFiMTI5NDI0MTkzZjdmZmM0NTFmOTNhZWIgPSAkKGA8ZGl2IGlkPSJodG1sXzkyZGEwZGVhYjEyOTQyNDE5M2Y3ZmZjNDUxZjkzYWViIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij4yNS43PC9kaXY+YClbMF07CiAgICAgICAgICAgIHBvcHVwXzk1ZTFmNDI3NThjODRjMGNhMDVmNjMyOGIwODQwZGRiLnNldENvbnRlbnQoaHRtbF85MmRhMGRlYWIxMjk0MjQxOTNmN2ZmYzQ1MWY5M2FlYik7CiAgICAgICAgCgogICAgICAgIHBvbHlfbGluZV85NTBiNTg5NTgxOTQ0YmYyOWQxMWJmMWE0NWJiOWM3ZC5iaW5kUG9wdXAocG9wdXBfOTVlMWY0Mjc1OGM4NGMwY2EwNWY2MzI4YjA4NDBkZGIpCiAgICAgICAgOwoKICAgICAgICAKICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb2x5X2xpbmVfMGFjMWNlNzJkOThlNDEzYWFkNjk1MTdkOWU0MzZjYWMgPSBMLnBvbHlsaW5lKAogICAgICAgICAgICAgICAgW1s2MC4xNjYxNDc0LCAyNC45MzQ2MDE4XSwgWzYwLjE2NjExNzUsIDI0LjkzNDUxNDhdXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjY2MwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiBmYWxzZSwgImZpbGxDb2xvciI6ICIjY2MwMDAwIiwgImZpbGxPcGFjaXR5IjogMC4yLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm5vQ2xpcCI6IGZhbHNlLCAib3BhY2l0eSI6IDEsICJzbW9vdGhGYWN0b3IiOiAxLjAsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogNX0KICAgICAgICAgICAgKS5hZGRUbyhtYXBfMGZiYzFiNzYxNzk0NGQ0NWI2NWM5YjkwNjgzZDQ0YjEpOwogICAgICAgIAogICAgCiAgICAgICAgdmFyIHBvcHVwXzBkNGVkOTdlYzhhYTRmODU4Y2QzZmUxZWExODFmZTU0ID0gTC5wb3B1cCh7Im1heFdpZHRoIjogIjEwMCUifSk7CgogICAgICAgIAogICAgICAgICAgICB2YXIgaHRtbF8yM2I3MWIxNzAyNzI0NjUyODkzMTE2MGNhZTg1OWIxMyA9ICQoYDxkaXYgaWQ9Imh0bWxfMjNiNzFiMTcwMjcyNDY1Mjg5MzExNjBjYWU4NTliMTMiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQuNzwvZGl2PmApWzBdOwogICAgICAgICAgICBwb3B1cF8wZDRlZDk3ZWM4YWE0Zjg1OGNkM2ZlMWVhMTgxZmU1NC5zZXRDb250ZW50KGh0bWxfMjNiNzFiMTcwMjcyNDY1Mjg5MzExNjBjYWU4NTliMTMpOwogICAgICAgIAoKICAgICAgICBwb2x5X2xpbmVfMGFjMWNlNzJkOThlNDEzYWFkNjk1MTdkOWU0MzZjYWMuYmluZFBvcHVwKHBvcHVwXzBkNGVkOTdlYzhhYTRmODU4Y2QzZmUxZWExODFmZTU0KQogICAgICAgIDsKCiAgICAgICAgCiAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9seV9saW5lXzE5OWNkMDc1ZmExOTQzZTNiMjk3NmY1NTY1M2FhYzhmID0gTC5wb2x5bGluZSgKICAgICAgICAgICAgICAgIFtbNjAuMTY2MTE3NSwgMjQuOTM0NTE0OF0sIFs2MC4xNjYwODY2LCAyNC45MzQ0MjQ5XV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiI2NjMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogZmFsc2UsICJmaWxsQ29sb3IiOiAiI2NjMDAwMCIsICJmaWxsT3BhY2l0eSI6IDAuMiwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJub0NsaXAiOiBmYWxzZSwgIm9wYWNpdHkiOiAxLCAic21vb3RoRmFjdG9yIjogMS4wLCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDV9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzBmYmMxYjc2MTc5NDRkNDViNjVjOWI5MDY4M2Q0NGIxKTsKICAgICAgICAKICAgIAogICAgICAgIHZhciBwb3B1cF9hMjNlMGE2YTFiZWY0YWQwODViM2NkNDk3NDBmODBhNSA9IEwucG9wdXAoeyJtYXhXaWR0aCI6ICIxMDAlIn0pOwoKICAgICAgICAKICAgICAgICAgICAgdmFyIGh0bWxfNjYxZjFlN2NiYjNiNDJlYzk2ZDNkNGJlZTQwNjVmMTQgPSAkKGA8ZGl2IGlkPSJodG1sXzY2MWYxZTdjYmIzYjQyZWM5NmQzZDRiZWU0MDY1ZjE0IiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40Ljg8L2Rpdj5gKVswXTsKICAgICAgICAgICAgcG9wdXBfYTIzZTBhNmExYmVmNGFkMDg1YjNjZDQ5NzQwZjgwYTUuc2V0Q29udGVudChodG1sXzY2MWYxZTdjYmIzYjQyZWM5NmQzZDRiZWU0MDY1ZjE0KTsKICAgICAgICAKCiAgICAgICAgcG9seV9saW5lXzE5OWNkMDc1ZmExOTQzZTNiMjk3NmY1NTY1M2FhYzhmLmJpbmRQb3B1cChwb3B1cF9hMjNlMGE2YTFiZWY0YWQwODViM2NkNDk3NDBmODBhNSkKICAgICAgICA7CgogICAgICAgIAogICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvbHlfbGluZV8xYzc5YWZlMjI5ZDA0NWFjYTk0ODhjNjdkZGQwNGUwOCA9IEwucG9seWxpbmUoCiAgICAgICAgICAgICAgICBbWzYwLjE2NjA4NjYsIDI0LjkzNDQyNDldLCBbNjAuMTY2MDY4MiwgMjQuOTM0MzcyNV0sIFs2MC4xNjU3MzcxLCAyNC45MzM0Mjk0XV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiI2NjMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogZmFsc2UsICJmaWxsQ29sb3IiOiAiI2NjMDAwMCIsICJmaWxsT3BhY2l0eSI6IDAuMiwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJub0NsaXAiOiBmYWxzZSwgIm9wYWNpdHkiOiAxLCAic21vb3RoRmFjdG9yIjogMS4wLCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDV9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzBmYmMxYjc2MTc5NDRkNDViNjVjOWI5MDY4M2Q0NGIxKTsKICAgICAgICAKICAgIAogICAgICAgIHZhciBwb3B1cF81YzhkOTI2NzcxYzE0M2QyOTRjMThmMDk2NjFlMWM3YyA9IEwucG9wdXAoeyJtYXhXaWR0aCI6ICIxMDAlIn0pOwoKICAgICAgICAKICAgICAgICAgICAgdmFyIGh0bWxfYzliYTgxZTU5OTI0NGI3NDhhNTEyMmQ3ZmU3ZWM0MTEgPSAkKGA8ZGl2IGlkPSJodG1sX2M5YmE4MWU1OTkyNDRiNzQ4YTUxMjJkN2ZlN2VjNDExIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij41My45PC9kaXY+YClbMF07CiAgICAgICAgICAgIHBvcHVwXzVjOGQ5MjY3NzFjMTQzZDI5NGMxOGYwOTY2MWUxYzdjLnNldENvbnRlbnQoaHRtbF9jOWJhODFlNTk5MjQ0Yjc0OGE1MTIyZDdmZTdlYzQxMSk7CiAgICAgICAgCgogICAgICAgIHBvbHlfbGluZV8xYzc5YWZlMjI5ZDA0NWFjYTk0ODhjNjdkZGQwNGUwOC5iaW5kUG9wdXAocG9wdXBfNWM4ZDkyNjc3MWMxNDNkMjk0YzE4ZjA5NjYxZTFjN2MpCiAgICAgICAgOwoKICAgICAgICAKICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb2x5X2xpbmVfNDUyODRiZjQwMjZlNGNjNmE4Mjg3OTBlMTM5ZTZhMDUgPSBMLnBvbHlsaW5lKAogICAgICAgICAgICAgICAgW1s2MC4xNjU3MzcxLCAyNC45MzM0Mjk0XSwgWzYwLjE2NTc4NDMsIDI0LjkzMzM2ODldXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjY2MwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiBmYWxzZSwgImZpbGxDb2xvciI6ICIjY2MwMDAwIiwgImZpbGxPcGFjaXR5IjogMC4yLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm5vQ2xpcCI6IGZhbHNlLCAib3BhY2l0eSI6IDEsICJzbW9vdGhGYWN0b3IiOiAxLjAsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogNX0KICAgICAgICAgICAgKS5hZGRUbyhtYXBfMGZiYzFiNzYxNzk0NGQ0NWI2NWM5YjkwNjgzZDQ0YjEpOwogICAgICAgIAogICAgCiAgICAgICAgdmFyIHBvcHVwXzM0ZTU3YmE3YTk5ODQ5NWViOGNkNjBjYjYwNjQ0MmFjID0gTC5wb3B1cCh7Im1heFdpZHRoIjogIjEwMCUifSk7CgogICAgICAgIAogICAgICAgICAgICB2YXIgaHRtbF8xMjE5ZjVjOGFlOWQ0ODNjODk0ZDBmMDU0ZGRlMjE1NSA9ICQoYDxkaXYgaWQ9Imh0bWxfMTIxOWY1YzhhZTlkNDgzYzg5NGQwZjA1NGRkZTIxNTUiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjUuMDwvZGl2PmApWzBdOwogICAgICAgICAgICBwb3B1cF8zNGU1N2JhN2E5OTg0OTVlYjhjZDYwY2I2MDY0NDJhYy5zZXRDb250ZW50KGh0bWxfMTIxOWY1YzhhZTlkNDgzYzg5NGQwZjA1NGRkZTIxNTUpOwogICAgICAgIAoKICAgICAgICBwb2x5X2xpbmVfNDUyODRiZjQwMjZlNGNjNmE4Mjg3OTBlMTM5ZTZhMDUuYmluZFBvcHVwKHBvcHVwXzM0ZTU3YmE3YTk5ODQ5NWViOGNkNjBjYjYwNjQ0MmFjKQogICAgICAgIDsKCiAgICAgICAgCiAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9seV9saW5lXzU1OGM1MzVmMWZmZTQ3MjU5ODNlYjdkODk3NzA0ZDZmID0gTC5wb2x5bGluZSgKICAgICAgICAgICAgICAgIFtbNjAuMTY1Nzg0MywgMjQuOTMzMzY4OV0sIFs2MC4xNjU3OTM5LCAyNC45MzMzNTMzXSwgWzYwLjE2NTg4MiwgMjQuOTMzMjI0OF0sIFs2MC4xNjU5MDgzLCAyNC45MzMxNzZdLCBbNjAuMTY1OTcwMSwgMjQuOTMzMDg1OV0sIFs2MC4xNjYwMzE1LCAyNC45MzI5NDRdLCBbNjAuMTY2MTAzNiwgMjQuOTMyODA5OV0sIFs2MC4xNjYxMTM3LCAyNC45MzI3OTE3XSwgWzYwLjE2NjIwODIsIDI0LjkzMjY1NjVdLCBbNjAuMTY2MjE4LCAyNC45MzI2NDIxXV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiI2NjMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogZmFsc2UsICJmaWxsQ29sb3IiOiAiI2NjMDAwMCIsICJmaWxsT3BhY2l0eSI6IDAuMiwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJub0NsaXAiOiBmYWxzZSwgIm9wYWNpdHkiOiAxLCAic21vb3RoRmFjdG9yIjogMS4wLCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDV9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzBmYmMxYjc2MTc5NDRkNDViNjVjOWI5MDY4M2Q0NGIxKTsKICAgICAgICAKICAgIAogICAgICAgIHZhciBwb3B1cF9iMjUwOGIxYTI3YmM0NWE5ODNiZGM4NGRhMTIyYjk0OCA9IEwucG9wdXAoeyJtYXhXaWR0aCI6ICIxMDAlIn0pOwoKICAgICAgICAKICAgICAgICAgICAgdmFyIGh0bWxfYzIyZGY2NGViOWU5NDQ4NzliODhmYzc3ZWJmZjlhZWEgPSAkKGA8ZGl2IGlkPSJodG1sX2MyMmRmNjRlYjllOTQ0ODc5Yjg4ZmM3N2ViZmY5YWVhIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij41MC40PC9kaXY+YClbMF07CiAgICAgICAgICAgIHBvcHVwX2IyNTA4YjFhMjdiYzQ1YTk4M2JkYzg0ZGExMjJiOTQ4LnNldENvbnRlbnQoaHRtbF9jMjJkZjY0ZWI5ZTk0NDg3OWI4OGZjNzdlYmZmOWFlYSk7CiAgICAgICAgCgogICAgICAgIHBvbHlfbGluZV81NThjNTM1ZjFmZmU0NzI1OTgzZWI3ZDg5NzcwNGQ2Zi5iaW5kUG9wdXAocG9wdXBfYjI1MDhiMWEyN2JjNDVhOTgzYmRjODRkYTEyMmI5NDgpCiAgICAgICAgOwoKICAgICAgICAKICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb2x5X2xpbmVfOWY3ZTNkNjFjMDA3NDQ5ZGEyMmI4YjYzMTY2YTAzOGUgPSBMLnBvbHlsaW5lKAogICAgICAgICAgICAgICAgW1s2MC4xNjYyMTgsIDI0LjkzMjY0MjFdLCBbNjAuMTY2MjU1OSwgMjQuOTMyNTZdXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjY2MwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiBmYWxzZSwgImZpbGxDb2xvciI6ICIjY2MwMDAwIiwgImZpbGxPcGFjaXR5IjogMC4yLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm5vQ2xpcCI6IGZhbHNlLCAib3BhY2l0eSI6IDEsICJzbW9vdGhGYWN0b3IiOiAxLjAsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogNX0KICAgICAgICAgICAgKS5hZGRUbyhtYXBfMGZiYzFiNzYxNzk0NGQ0NWI2NWM5YjkwNjgzZDQ0YjEpOwogICAgICAgIAogICAgCiAgICAgICAgdmFyIHBvcHVwX2ViMTJiYzQzYzljZDQwZTliNGZlZTNmYTdiNWZjMzcyID0gTC5wb3B1cCh7Im1heFdpZHRoIjogIjEwMCUifSk7CgogICAgICAgIAogICAgICAgICAgICB2YXIgaHRtbF8xOTBlZTY5Mjk2NjI0ZTY1YTEwM2YxMDJhNmU2ZDE4YyA9ICQoYDxkaXYgaWQ9Imh0bWxfMTkwZWU2OTI5NjYyNGU2NWExMDNmMTAyYTZlNmQxOGMiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjUuMDwvZGl2PmApWzBdOwogICAgICAgICAgICBwb3B1cF9lYjEyYmM0M2M5Y2Q0MGU5YjRmZWUzZmE3YjVmYzM3Mi5zZXRDb250ZW50KGh0bWxfMTkwZWU2OTI5NjYyNGU2NWExMDNmMTAyYTZlNmQxOGMpOwogICAgICAgIAoKICAgICAgICBwb2x5X2xpbmVfOWY3ZTNkNjFjMDA3NDQ5ZGEyMmI4YjYzMTY2YTAzOGUuYmluZFBvcHVwKHBvcHVwX2ViMTJiYzQzYzljZDQwZTliNGZlZTNmYTdiNWZjMzcyKQogICAgICAgIDsKCiAgICAgICAgCiAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9seV9saW5lX2RhMGRlMjQwMzAwNTQxMDNhZjhiYjI0YTNiZWJjOGM3ID0gTC5wb2x5bGluZSgKICAgICAgICAgICAgICAgIFtbNjAuMTY2MjU1OSwgMjQuOTMyNTZdLCBbNjAuMTY2MjIwOCwgMjQuOTMyNDU5Ml1dLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiNjYzAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IGZhbHNlLCAiZmlsbENvbG9yIjogIiNjYzAwMDAiLCAiZmlsbE9wYWNpdHkiOiAwLjIsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAibm9DbGlwIjogZmFsc2UsICJvcGFjaXR5IjogMSwgInNtb290aEZhY3RvciI6IDEuMCwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiA1fQogICAgICAgICAgICApLmFkZFRvKG1hcF8wZmJjMWI3NjE3OTQ0ZDQ1YjY1YzliOTA2ODNkNDRiMSk7CiAgICAgICAgCiAgICAKICAgICAgICB2YXIgcG9wdXBfMzBmMzA4OWFiMjkyNGQ3NTgzMTZlOTg1YzZmMTZkMDEgPSBMLnBvcHVwKHsibWF4V2lkdGgiOiAiMTAwJSJ9KTsKCiAgICAgICAgCiAgICAgICAgICAgIHZhciBodG1sXzQzZGRhMmQ0YmU2YzQzYzQ4NzhjZGNkZTExZDA3YWRmID0gJChgPGRpdiBpZD0iaHRtbF80M2RkYTJkNGJlNmM0M2M0ODc4Y2RjZGUxMWQwN2FkZiIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NS40PC9kaXY+YClbMF07CiAgICAgICAgICAgIHBvcHVwXzMwZjMwODlhYjI5MjRkNzU4MzE2ZTk4NWM2ZjE2ZDAxLnNldENvbnRlbnQoaHRtbF80M2RkYTJkNGJlNmM0M2M0ODc4Y2RjZGUxMWQwN2FkZik7CiAgICAgICAgCgogICAgICAgIHBvbHlfbGluZV9kYTBkZTI0MDMwMDU0MTAzYWY4YmIyNGEzYmViYzhjNy5iaW5kUG9wdXAocG9wdXBfMzBmMzA4OWFiMjkyNGQ3NTgzMTZlOTg1YzZmMTZkMDEpCiAgICAgICAgOwoKICAgICAgICAKICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb2x5X2xpbmVfNjkyMGRmODFmODNmNDAzMGE0YzBlNDc5NjZjY2JiN2IgPSBMLnBvbHlsaW5lKAogICAgICAgICAgICAgICAgW1s2MC4xNjYyMjA4LCAyNC45MzI0NTkyXSwgWzYwLjE2NjI1MzYsIDI0LjkzMjM2XV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiI2NjMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogZmFsc2UsICJmaWxsQ29sb3IiOiAiI2NjMDAwMCIsICJmaWxsT3BhY2l0eSI6IDAuMiwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJub0NsaXAiOiBmYWxzZSwgIm9wYWNpdHkiOiAxLCAic21vb3RoRmFjdG9yIjogMS4wLCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDV9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzBmYmMxYjc2MTc5NDRkNDViNjVjOWI5MDY4M2Q0NGIxKTsKICAgICAgICAKICAgIAogICAgICAgIHZhciBwb3B1cF8wMzAzZTdlZjFmNzI0ZWE3OTNhZDUwOWZiYmE3OWM1ZCA9IEwucG9wdXAoeyJtYXhXaWR0aCI6ICIxMDAlIn0pOwoKICAgICAgICAKICAgICAgICAgICAgdmFyIGh0bWxfMzRjMjc3NWQwMzQyNGFiNDhlZmZlOTZiZWI2OGI0NGQgPSAkKGA8ZGl2IGlkPSJodG1sXzM0YzI3NzVkMDM0MjRhYjQ4ZWZmZTk2YmViNjhiNDRkIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij41LjM8L2Rpdj5gKVswXTsKICAgICAgICAgICAgcG9wdXBfMDMwM2U3ZWYxZjcyNGVhNzkzYWQ1MDlmYmJhNzljNWQuc2V0Q29udGVudChodG1sXzM0YzI3NzVkMDM0MjRhYjQ4ZWZmZTk2YmViNjhiNDRkKTsKICAgICAgICAKCiAgICAgICAgcG9seV9saW5lXzY5MjBkZjgxZjgzZjQwMzBhNGMwZTQ3OTY2Y2NiYjdiLmJpbmRQb3B1cChwb3B1cF8wMzAzZTdlZjFmNzI0ZWE3OTNhZDUwOWZiYmE3OWM1ZCkKICAgICAgICA7CgogICAgICAgIAogICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvbHlfbGluZV80MzBkMGQzYzAxZmQ0Mzg2YjBmYTdkYjYwZTBiMzFmOSA9IEwucG9seWxpbmUoCiAgICAgICAgICAgICAgICBbWzYwLjE2NjI1MzYsIDI0LjkzMjM2XSwgWzYwLjE2NjE5ODIsIDI0LjkzMjIwM11dLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiNjYzAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IGZhbHNlLCAiZmlsbENvbG9yIjogIiNjYzAwMDAiLCAiZmlsbE9wYWNpdHkiOiAwLjIsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAibm9DbGlwIjogZmFsc2UsICJvcGFjaXR5IjogMSwgInNtb290aEZhY3RvciI6IDEuMCwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiA1fQogICAgICAgICAgICApLmFkZFRvKG1hcF8wZmJjMWI3NjE3OTQ0ZDQ1YjY1YzliOTA2ODNkNDRiMSk7CiAgICAgICAgCiAgICAKICAgICAgICB2YXIgcG9wdXBfOWNhYzdlNzFiYzljNDRjMzgzMjQ0M2FhZjc2YjMyMjUgPSBMLnBvcHVwKHsibWF4V2lkdGgiOiAiMTAwJSJ9KTsKCiAgICAgICAgCiAgICAgICAgICAgIHZhciBodG1sXzdiMGM0YmU3NzNhOTQ1ZWFhZTQ3N2EwNzc0NzUzOTcwID0gJChgPGRpdiBpZD0iaHRtbF83YjBjNGJlNzczYTk0NWVhYWU0NzdhMDc3NDc1Mzk3MCIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+OC41PC9kaXY+YClbMF07CiAgICAgICAgICAgIHBvcHVwXzljYWM3ZTcxYmM5YzQ0YzM4MzI0NDNhYWY3NmIzMjI1LnNldENvbnRlbnQoaHRtbF83YjBjNGJlNzczYTk0NWVhYWU0NzdhMDc3NDc1Mzk3MCk7CiAgICAgICAgCgogICAgICAgIHBvbHlfbGluZV80MzBkMGQzYzAxZmQ0Mzg2YjBmYTdkYjYwZTBiMzFmOS5iaW5kUG9wdXAocG9wdXBfOWNhYzdlNzFiYzljNDRjMzgzMjQ0M2FhZjc2YjMyMjUpCiAgICAgICAgOwoKICAgICAgICAKICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb2x5X2xpbmVfMzkzNDM3Y2U2MWVmNDA1NjgzN2E0ZTgyZDFiNzViMDIgPSBMLnBvbHlsaW5lKAogICAgICAgICAgICAgICAgW1s2MC4xNjYxOTgyLCAyNC45MzIyMDNdLCBbNjAuMTY1ODU2NCwgMjQuOTMxMjUyMV1dLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiNjYzAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IGZhbHNlLCAiZmlsbENvbG9yIjogIiNjYzAwMDAiLCAiZmlsbE9wYWNpdHkiOiAwLjIsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAibm9DbGlwIjogZmFsc2UsICJvcGFjaXR5IjogMSwgInNtb290aEZhY3RvciI6IDEuMCwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiA1fQogICAgICAgICAgICApLmFkZFRvKG1hcF8wZmJjMWI3NjE3OTQ0ZDQ1YjY1YzliOTA2ODNkNDRiMSk7CiAgICAgICAgCiAgICAKICAgICAgICB2YXIgcG9wdXBfMWU1YzdmZGVhNzg4NDY5ZjhiNTIzYTkzMGExZjZjMWYgPSBMLnBvcHVwKHsibWF4V2lkdGgiOiAiMTAwJSJ9KTsKCiAgICAgICAgCiAgICAgICAgICAgIHZhciBodG1sXzJlN2YxMTZhYmVkOTRjNDNiYzIzODVhZDRhOWY3MWE0ID0gJChgPGRpdiBpZD0iaHRtbF8yZTdmMTE2YWJlZDk0YzQzYmMyMzg1YWQ0YTlmNzFhNCIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NTEuOTwvZGl2PmApWzBdOwogICAgICAgICAgICBwb3B1cF8xZTVjN2ZkZWE3ODg0NjlmOGI1MjNhOTMwYTFmNmMxZi5zZXRDb250ZW50KGh0bWxfMmU3ZjExNmFiZWQ5NGM0M2JjMjM4NWFkNGE5ZjcxYTQpOwogICAgICAgIAoKICAgICAgICBwb2x5X2xpbmVfMzkzNDM3Y2U2MWVmNDA1NjgzN2E0ZTgyZDFiNzViMDIuYmluZFBvcHVwKHBvcHVwXzFlNWM3ZmRlYTc4ODQ2OWY4YjUyM2E5MzBhMWY2YzFmKQogICAgICAgIDsKCiAgICAgICAgCiAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9seV9saW5lXzY5NDVmNWE3MzIzODQwYzBhYWIyYjQ5NWViNzgzZGM4ID0gTC5wb2x5bGluZSgKICAgICAgICAgICAgICAgIFtbNjAuMTY1ODU2NCwgMjQuOTMxMjUyMV0sIFs2MC4xNjU4MjE4LCAyNC45MzExNjE0XV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiI2NjMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogZmFsc2UsICJmaWxsQ29sb3IiOiAiI2NjMDAwMCIsICJmaWxsT3BhY2l0eSI6IDAuMiwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJub0NsaXAiOiBmYWxzZSwgIm9wYWNpdHkiOiAxLCAic21vb3RoRmFjdG9yIjogMS4wLCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDV9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzBmYmMxYjc2MTc5NDRkNDViNjVjOWI5MDY4M2Q0NGIxKTsKICAgICAgICAKICAgIAogICAgICAgIHZhciBwb3B1cF9kY2Q0MDg4NDRiYmI0ZGU1YWViNDYzNTIxZmMzNTc3NiA9IEwucG9wdXAoeyJtYXhXaWR0aCI6ICIxMDAlIn0pOwoKICAgICAgICAKICAgICAgICAgICAgdmFyIGh0bWxfM2NmNzk0MTg5MGMxNGRlYWI5ZTJhMDA0Zjk0MDZlZjMgPSAkKGA8ZGl2IGlkPSJodG1sXzNjZjc5NDE4OTBjMTRkZWFiOWUyYTAwNGY5NDA2ZWYzIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij41LjE8L2Rpdj5gKVswXTsKICAgICAgICAgICAgcG9wdXBfZGNkNDA4ODQ0YmJiNGRlNWFlYjQ2MzUyMWZjMzU3NzYuc2V0Q29udGVudChodG1sXzNjZjc5NDE4OTBjMTRkZWFiOWUyYTAwNGY5NDA2ZWYzKTsKICAgICAgICAKCiAgICAgICAgcG9seV9saW5lXzY5NDVmNWE3MzIzODQwYzBhYWIyYjQ5NWViNzgzZGM4LmJpbmRQb3B1cChwb3B1cF9kY2Q0MDg4NDRiYmI0ZGU1YWViNDYzNTIxZmMzNTc3NikKICAgICAgICA7CgogICAgICAgIAogICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvbHlfbGluZV8yYjM1OTc5Y2RhMWE0MTRiOGZiZGMxMTY1MWYyNmMzNyA9IEwucG9seWxpbmUoCiAgICAgICAgICAgICAgICBbWzYwLjE2NTgyMTgsIDI0LjkzMTE2MTRdLCBbNjAuMTY1NzkzOSwgMjQuOTMxMDgxMl1dLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiNjYzAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IGZhbHNlLCAiZmlsbENvbG9yIjogIiNjYzAwMDAiLCAiZmlsbE9wYWNpdHkiOiAwLjIsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAibm9DbGlwIjogZmFsc2UsICJvcGFjaXR5IjogMSwgInNtb290aEZhY3RvciI6IDEuMCwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiA1fQogICAgICAgICAgICApLmFkZFRvKG1hcF8wZmJjMWI3NjE3OTQ0ZDQ1YjY1YzliOTA2ODNkNDRiMSk7CiAgICAgICAgCiAgICAKICAgICAgICB2YXIgcG9wdXBfYWVlMzk4OWE0YTYyNDgyNDkxNDgzMTdlMmVlOTFlOTggPSBMLnBvcHVwKHsibWF4V2lkdGgiOiAiMTAwJSJ9KTsKCiAgICAgICAgCiAgICAgICAgICAgIHZhciBodG1sXzA4YTkzYTI0Y2NiNDQ1NzQ4MmM3ZmIwYjI2MmM0YWRhID0gJChgPGRpdiBpZD0iaHRtbF8wOGE5M2EyNGNjYjQ0NTc0ODJjN2ZiMGIyNjJjNGFkYSIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NC4zPC9kaXY+YClbMF07CiAgICAgICAgICAgIHBvcHVwX2FlZTM5ODlhNGE2MjQ4MjQ5MTQ4MzE3ZTJlZTkxZTk4LnNldENvbnRlbnQoaHRtbF8wOGE5M2EyNGNjYjQ0NTc0ODJjN2ZiMGIyNjJjNGFkYSk7CiAgICAgICAgCgogICAgICAgIHBvbHlfbGluZV8yYjM1OTc5Y2RhMWE0MTRiOGZiZGMxMTY1MWYyNmMzNy5iaW5kUG9wdXAocG9wdXBfYWVlMzk4OWE0YTYyNDgyNDkxNDgzMTdlMmVlOTFlOTgpCiAgICAgICAgOwoKICAgICAgICAKICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb2x5X2xpbmVfNDZiN2Y5MWQyZmM4NGZjNDhkY2VkMzE0ODY2YzYzMTAgPSBMLnBvbHlsaW5lKAogICAgICAgICAgICAgICAgW1s2MC4xNjU3OTM5LCAyNC45MzEwODEyXSwgWzYwLjE2NDg1OTMsIDI0LjkyODQ0MTRdXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjY2MwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiBmYWxzZSwgImZpbGxDb2xvciI6ICIjY2MwMDAwIiwgImZpbGxPcGFjaXR5IjogMC4yLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm5vQ2xpcCI6IGZhbHNlLCAib3BhY2l0eSI6IDEsICJzbW9vdGhGYWN0b3IiOiAxLjAsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogNX0KICAgICAgICAgICAgKS5hZGRUbyhtYXBfMGZiYzFiNzYxNzk0NGQ0NWI2NWM5YjkwNjgzZDQ0YjEpOwogICAgICAgIAogICAgCiAgICAgICAgdmFyIHBvcHVwXzYwMjY1YWY1Yjk2YjQwNzY4ZjE1OWI4OTkwZGYzYzFmID0gTC5wb3B1cCh7Im1heFdpZHRoIjogIjEwMCUifSk7CgogICAgICAgIAogICAgICAgICAgICB2YXIgaHRtbF8xMDJlYTAxZWU2ZjE0NTc3YWZiY2QzMTRiZjM1YTU4ZiA9ICQoYDxkaXYgaWQ9Imh0bWxfMTAyZWEwMWVlNmYxNDU3N2FmYmNkMzE0YmYzNWE1OGYiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjE0My40PC9kaXY+YClbMF07CiAgICAgICAgICAgIHBvcHVwXzYwMjY1YWY1Yjk2YjQwNzY4ZjE1OWI4OTkwZGYzYzFmLnNldENvbnRlbnQoaHRtbF8xMDJlYTAxZWU2ZjE0NTc3YWZiY2QzMTRiZjM1YTU4Zik7CiAgICAgICAgCgogICAgICAgIHBvbHlfbGluZV80NmI3ZjkxZDJmYzg0ZmM0OGRjZWQzMTQ4NjZjNjMxMC5iaW5kUG9wdXAocG9wdXBfNjAyNjVhZjViOTZiNDA3NjhmMTU5Yjg5OTBkZjNjMWYpCiAgICAgICAgOwoKICAgICAgICAKICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb2x5X2xpbmVfNGRiNzE1MzY0ZmRmNDc2MDgzZjk3ZTY5ZWFkNGMwNmMgPSBMLnBvbHlsaW5lKAogICAgICAgICAgICAgICAgW1s2MC4xNjQ4NTkzLCAyNC45Mjg0NDE0XSwgWzYwLjE2NDgyOTksIDI0LjkyODM2MzhdXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjY2MwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiBmYWxzZSwgImZpbGxDb2xvciI6ICIjY2MwMDAwIiwgImZpbGxPcGFjaXR5IjogMC4yLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm5vQ2xpcCI6IGZhbHNlLCAib3BhY2l0eSI6IDEsICJzbW9vdGhGYWN0b3IiOiAxLjAsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogNX0KICAgICAgICAgICAgKS5hZGRUbyhtYXBfMGZiYzFiNzYxNzk0NGQ0NWI2NWM5YjkwNjgzZDQ0YjEpOwogICAgICAgIAogICAgCiAgICAgICAgdmFyIHBvcHVwXzI2MTllNmNlM2MwNDQ0Y2FhMjZhMWExMWQ5NzQwYjQ1ID0gTC5wb3B1cCh7Im1heFdpZHRoIjogIjEwMCUifSk7CgogICAgICAgIAogICAgICAgICAgICB2YXIgaHRtbF82YTA3OTI3NGIxY2Y0NmUxOGI4N2JmM2ExZmJhMzdiMyA9ICQoYDxkaXYgaWQ9Imh0bWxfNmEwNzkyNzRiMWNmNDZlMThiODdiZjNhMWZiYTM3YjMiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjQuMzwvZGl2PmApWzBdOwogICAgICAgICAgICBwb3B1cF8yNjE5ZTZjZTNjMDQ0NGNhYTI2YTFhMTFkOTc0MGI0NS5zZXRDb250ZW50KGh0bWxfNmEwNzkyNzRiMWNmNDZlMThiODdiZjNhMWZiYTM3YjMpOwogICAgICAgIAoKICAgICAgICBwb2x5X2xpbmVfNGRiNzE1MzY0ZmRmNDc2MDgzZjk3ZTY5ZWFkNGMwNmMuYmluZFBvcHVwKHBvcHVwXzI2MTllNmNlM2MwNDQ0Y2FhMjZhMWExMWQ5NzQwYjQ1KQogICAgICAgIDsKCiAgICAgICAgCiAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9seV9saW5lX2I2YzMwZjA2ZmQ1NTRmNGY5NDQxYmU5YzJkMTM3OWVlID0gTC5wb2x5bGluZSgKICAgICAgICAgICAgICAgIFtbNjAuMTY0ODI5OSwgMjQuOTI4MzYzOF0sIFs2MC4xNjQ3OTYxLCAyNC45MjgyNjk4XV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiI2NjMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogZmFsc2UsICJmaWxsQ29sb3IiOiAiI2NjMDAwMCIsICJmaWxsT3BhY2l0eSI6IDAuMiwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJub0NsaXAiOiBmYWxzZSwgIm9wYWNpdHkiOiAxLCAic21vb3RoRmFjdG9yIjogMS4wLCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDV9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzBmYmMxYjc2MTc5NDRkNDViNjVjOWI5MDY4M2Q0NGIxKTsKICAgICAgICAKICAgIAogICAgICAgIHZhciBwb3B1cF9jNjMyZjk0MTA1ZjE0Mjc0OTFiZTNiNTdhOGNhMmQ5YiA9IEwucG9wdXAoeyJtYXhXaWR0aCI6ICIxMDAlIn0pOwoKICAgICAgICAKICAgICAgICAgICAgdmFyIGh0bWxfZTc2ZmM1NmIzNzhlNGQ5MWJiNzVkZmUwNzFjOTFkMGEgPSAkKGA8ZGl2IGlkPSJodG1sX2U3NmZjNTZiMzc4ZTRkOTFiYjc1ZGZlMDcxYzkxZDBhIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij41LjE8L2Rpdj5gKVswXTsKICAgICAgICAgICAgcG9wdXBfYzYzMmY5NDEwNWYxNDI3NDkxYmUzYjU3YThjYTJkOWIuc2V0Q29udGVudChodG1sX2U3NmZjNTZiMzc4ZTRkOTFiYjc1ZGZlMDcxYzkxZDBhKTsKICAgICAgICAKCiAgICAgICAgcG9seV9saW5lX2I2YzMwZjA2ZmQ1NTRmNGY5NDQxYmU5YzJkMTM3OWVlLmJpbmRQb3B1cChwb3B1cF9jNjMyZjk0MTA1ZjE0Mjc0OTFiZTNiNTdhOGNhMmQ5YikKICAgICAgICA7CgogICAgICAgIAogICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvbHlfbGluZV9mN2RiNzg0Zjk5YTk0MGJlODIyNzlmZDI4Y2NjNzMwNSA9IEwucG9seWxpbmUoCiAgICAgICAgICAgICAgICBbWzYwLjE2NDc5NjEsIDI0LjkyODI2OThdLCBbNjAuMTY0MzMyNCwgMjQuOTI2OTc3M11dLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiNjYzAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IGZhbHNlLCAiZmlsbENvbG9yIjogIiNjYzAwMDAiLCAiZmlsbE9wYWNpdHkiOiAwLjIsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAibm9DbGlwIjogZmFsc2UsICJvcGFjaXR5IjogMSwgInNtb290aEZhY3RvciI6IDEuMCwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiA1fQogICAgICAgICAgICApLmFkZFRvKG1hcF8wZmJjMWI3NjE3OTQ0ZDQ1YjY1YzliOTA2ODNkNDRiMSk7CiAgICAgICAgCiAgICAKICAgICAgICB2YXIgcG9wdXBfNjBhOTVlYzMwY2UxNDUxYmI4ZmQ1ZjAyNzQxYzIwNzcgPSBMLnBvcHVwKHsibWF4V2lkdGgiOiAiMTAwJSJ9KTsKCiAgICAgICAgCiAgICAgICAgICAgIHZhciBodG1sXzVhZWU2ZTk0MTNiZjQ3MzE5OTI0NGIyYzFiYjVmN2QwID0gJChgPGRpdiBpZD0iaHRtbF81YWVlNmU5NDEzYmY0NzMxOTkyNDRiMmMxYmI1ZjdkMCIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+NzAuNTwvZGl2PmApWzBdOwogICAgICAgICAgICBwb3B1cF82MGE5NWVjMzBjZTE0NTFiYjhmZDVmMDI3NDFjMjA3Ny5zZXRDb250ZW50KGh0bWxfNWFlZTZlOTQxM2JmNDczMTk5MjQ0YjJjMWJiNWY3ZDApOwogICAgICAgIAoKICAgICAgICBwb2x5X2xpbmVfZjdkYjc4NGY5OWE5NDBiZTgyMjc5ZmQyOGNjYzczMDUuYmluZFBvcHVwKHBvcHVwXzYwYTk1ZWMzMGNlMTQ1MWJiOGZkNWYwMjc0MWMyMDc3KQogICAgICAgIDsKCiAgICAgICAgCiAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9seV9saW5lX2VlYzBjNzhiZjZmYTRjOGZiZDNlNWI0ZmEwZGI3N2I5ID0gTC5wb2x5bGluZSgKICAgICAgICAgICAgICAgIFtbNjAuMTY0MzMyNCwgMjQuOTI2OTc3M10sIFs2MC4xNjQyNzE4LCAyNC45MjY4MTQ4XSwgWzYwLjE2NDI3MzgsIDI0LjkyNjc3Nl1dLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiNjYzAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IGZhbHNlLCAiZmlsbENvbG9yIjogIiNjYzAwMDAiLCAiZmlsbE9wYWNpdHkiOiAwLjIsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAibm9DbGlwIjogZmFsc2UsICJvcGFjaXR5IjogMSwgInNtb290aEZhY3RvciI6IDEuMCwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiA1fQogICAgICAgICAgICApLmFkZFRvKG1hcF8wZmJjMWI3NjE3OTQ0ZDQ1YjY1YzliOTA2ODNkNDRiMSk7CiAgICAgICAgCiAgICAKICAgICAgICB2YXIgcG9wdXBfNWIwYzlhODU3YTRiNGNjN2I3ZjMyOWNlZWUyYzU4N2IgPSBMLnBvcHVwKHsibWF4V2lkdGgiOiAiMTAwJSJ9KTsKCiAgICAgICAgCiAgICAgICAgICAgIHZhciBodG1sX2YwYjliOTU1ZjVmZDRkNzNhNzFkOThhN2RkYWM0NTc2ID0gJChgPGRpdiBpZD0iaHRtbF9mMGI5Yjk1NWY1ZmQ0ZDczYTcxZDk4YTdkZGFjNDU3NiIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+MTAuNzwvZGl2PmApWzBdOwogICAgICAgICAgICBwb3B1cF81YjBjOWE4NTdhNGI0Y2M3YjdmMzI5Y2VlZTJjNTg3Yi5zZXRDb250ZW50KGh0bWxfZjBiOWI5NTVmNWZkNGQ3M2E3MWQ5OGE3ZGRhYzQ1NzYpOwogICAgICAgIAoKICAgICAgICBwb2x5X2xpbmVfZWVjMGM3OGJmNmZhNGM4ZmJkM2U1YjRmYTBkYjc3YjkuYmluZFBvcHVwKHBvcHVwXzViMGM5YTg1N2E0YjRjYzdiN2YzMjljZWVlMmM1ODdiKQogICAgICAgIDsKCiAgICAgICAgCiAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9seV9saW5lXzEzZDdjMTFmOGI2MzQ4ODA4MDIzM2VhYTk2YTRlOTFkID0gTC5wb2x5bGluZSgKICAgICAgICAgICAgICAgIFtbNjAuMTY0MjczOCwgMjQuOTI2Nzc2XSwgWzYwLjE2NDIyODUsIDI0LjkyNjY0ODRdXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjY2MwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiBmYWxzZSwgImZpbGxDb2xvciI6ICIjY2MwMDAwIiwgImZpbGxPcGFjaXR5IjogMC4yLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm5vQ2xpcCI6IGZhbHNlLCAib3BhY2l0eSI6IDEsICJzbW9vdGhGYWN0b3IiOiAxLjAsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogNX0KICAgICAgICAgICAgKS5hZGRUbyhtYXBfMGZiYzFiNzYxNzk0NGQ0NWI2NWM5YjkwNjgzZDQ0YjEpOwogICAgICAgIAogICAgCiAgICAgICAgdmFyIHBvcHVwX2M0OGFkZGFiNDMzMTQwMjI5ZDkxNDhlMDVmYzc0ZDhhID0gTC5wb3B1cCh7Im1heFdpZHRoIjogIjEwMCUifSk7CgogICAgICAgIAogICAgICAgICAgICB2YXIgaHRtbF8zYmM5YmRmMGZlNTE0YjBkYmFhZTBmZmUzODBkYTUyZiA9ICQoYDxkaXYgaWQ9Imh0bWxfM2JjOWJkZjBmZTUxNGIwZGJhYWUwZmZlMzgwZGE1MmYiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjYuOTwvZGl2PmApWzBdOwogICAgICAgICAgICBwb3B1cF9jNDhhZGRhYjQzMzE0MDIyOWQ5MTQ4ZTA1ZmM3NGQ4YS5zZXRDb250ZW50KGh0bWxfM2JjOWJkZjBmZTUxNGIwZGJhYWUwZmZlMzgwZGE1MmYpOwogICAgICAgIAoKICAgICAgICBwb2x5X2xpbmVfMTNkN2MxMWY4YjYzNDg4MDgwMjMzZWFhOTZhNGU5MWQuYmluZFBvcHVwKHBvcHVwX2M0OGFkZGFiNDMzMTQwMjI5ZDkxNDhlMDVmYzc0ZDhhKQogICAgICAgIDsKCiAgICAgICAgCiAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9seV9saW5lXzBhYzQ5MTFiNjAxNDRiYzRiMmQ0NDNhMjZjMzEwMzMyID0gTC5wb2x5bGluZSgKICAgICAgICAgICAgICAgIFtbNjAuMTY0MjI4NSwgMjQuOTI2NjQ4NF0sIFs2MC4xNjQxODUsIDI0LjkyNjUyOTNdXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjY2MwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiBmYWxzZSwgImZpbGxDb2xvciI6ICIjY2MwMDAwIiwgImZpbGxPcGFjaXR5IjogMC4yLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm5vQ2xpcCI6IGZhbHNlLCAib3BhY2l0eSI6IDEsICJzbW9vdGhGYWN0b3IiOiAxLjAsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogNX0KICAgICAgICAgICAgKS5hZGRUbyhtYXBfMGZiYzFiNzYxNzk0NGQ0NWI2NWM5YjkwNjgzZDQ0YjEpOwogICAgICAgIAogICAgCiAgICAgICAgdmFyIHBvcHVwX2M5ZjQ2MjUzYWZlZjQwMWRiM2MxY2EyOWMzYTMyMmM0ID0gTC5wb3B1cCh7Im1heFdpZHRoIjogIjEwMCUifSk7CgogICAgICAgIAogICAgICAgICAgICB2YXIgaHRtbF9mOGI4ZGU4MzM1NWM0OGZmYjlmZWE0NjIzMzVjNDVmZSA9ICQoYDxkaXYgaWQ9Imh0bWxfZjhiOGRlODMzNTVjNDhmZmI5ZmVhNDYyMzM1YzQ1ZmUiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjYuNTwvZGl2PmApWzBdOwogICAgICAgICAgICBwb3B1cF9jOWY0NjI1M2FmZWY0MDFkYjNjMWNhMjljM2EzMjJjNC5zZXRDb250ZW50KGh0bWxfZjhiOGRlODMzNTVjNDhmZmI5ZmVhNDYyMzM1YzQ1ZmUpOwogICAgICAgIAoKICAgICAgICBwb2x5X2xpbmVfMGFjNDkxMWI2MDE0NGJjNGIyZDQ0M2EyNmMzMTAzMzIuYmluZFBvcHVwKHBvcHVwX2M5ZjQ2MjUzYWZlZjQwMWRiM2MxY2EyOWMzYTMyMmM0KQogICAgICAgIDsKCiAgICAgICAgCiAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9seV9saW5lXzU3OTAyNjY4NjFiYTQ4ZWJiZWM1ZmQxNGQ5YTZhZWQ0ID0gTC5wb2x5bGluZSgKICAgICAgICAgICAgICAgIFtbNjAuMTY0MTg1LCAyNC45MjY1MjkzXSwgWzYwLjE2NDE0OTUsIDI0LjkyNjQyNjFdXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjY2MwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiBmYWxzZSwgImZpbGxDb2xvciI6ICIjY2MwMDAwIiwgImZpbGxPcGFjaXR5IjogMC4yLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm5vQ2xpcCI6IGZhbHNlLCAib3BhY2l0eSI6IDEsICJzbW9vdGhGYWN0b3IiOiAxLjAsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogNX0KICAgICAgICAgICAgKS5hZGRUbyhtYXBfMGZiYzFiNzYxNzk0NGQ0NWI2NWM5YjkwNjgzZDQ0YjEpOwogICAgICAgIAogICAgCiAgICAgICAgdmFyIHBvcHVwXzQzNzI1NDUyMjI3NjQ5MzZhMTAxMThlZmExZDkzNjM2ID0gTC5wb3B1cCh7Im1heFdpZHRoIjogIjEwMCUifSk7CgogICAgICAgIAogICAgICAgICAgICB2YXIgaHRtbF9mODNhM2U4YmE2OTM0MTczYTYzOTNlMzg5OWY1NjVmNiA9ICQoYDxkaXYgaWQ9Imh0bWxfZjgzYTNlOGJhNjkzNDE3M2E2MzkzZTM4OTlmNTY1ZjYiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjUuNjwvZGl2PmApWzBdOwogICAgICAgICAgICBwb3B1cF80MzcyNTQ1MjIyNzY0OTM2YTEwMTE4ZWZhMWQ5MzYzNi5zZXRDb250ZW50KGh0bWxfZjgzYTNlOGJhNjkzNDE3M2E2MzkzZTM4OTlmNTY1ZjYpOwogICAgICAgIAoKICAgICAgICBwb2x5X2xpbmVfNTc5MDI2Njg2MWJhNDhlYmJlYzVmZDE0ZDlhNmFlZDQuYmluZFBvcHVwKHBvcHVwXzQzNzI1NDUyMjI3NjQ5MzZhMTAxMThlZmExZDkzNjM2KQogICAgICAgIDsKCiAgICAgICAgCiAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9seV9saW5lX2RjYzQ5NjUxZDc0MjQ2YWRhZmRhNzA5YzUzYzQzM2FlID0gTC5wb2x5bGluZSgKICAgICAgICAgICAgICAgIFtbNjAuMTY0MTQ5NSwgMjQuOTI2NDI2MV0sIFs2MC4xNjM1NDA5LCAyNC45MjQ3MTA4XV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiI2NjMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogZmFsc2UsICJmaWxsQ29sb3IiOiAiI2NjMDAwMCIsICJmaWxsT3BhY2l0eSI6IDAuMiwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJub0NsaXAiOiBmYWxzZSwgIm9wYWNpdHkiOiAxLCAic21vb3RoRmFjdG9yIjogMS4wLCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDV9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzBmYmMxYjc2MTc5NDRkNDViNjVjOWI5MDY4M2Q0NGIxKTsKICAgICAgICAKICAgIAogICAgICAgIHZhciBwb3B1cF9hNjZjOWE3OWY1NDg0MGE2YTMzZGNiMjUxYzI1NTExMiA9IEwucG9wdXAoeyJtYXhXaWR0aCI6ICIxMDAlIn0pOwoKICAgICAgICAKICAgICAgICAgICAgdmFyIGh0bWxfYzFmNjc3Yzc3MTUzNDNiYmFmZjkzZWQ2OTNiYzBhNjUgPSAkKGA8ZGl2IGlkPSJodG1sX2MxZjY3N2M3NzE1MzQzYmJhZmY5M2VkNjkzYmMwYTY1IiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij45My4yPC9kaXY+YClbMF07CiAgICAgICAgICAgIHBvcHVwX2E2NmM5YTc5ZjU0ODQwYTZhMzNkY2IyNTFjMjU1MTEyLnNldENvbnRlbnQoaHRtbF9jMWY2NzdjNzcxNTM0M2JiYWZmOTNlZDY5M2JjMGE2NSk7CiAgICAgICAgCgogICAgICAgIHBvbHlfbGluZV9kY2M0OTY1MWQ3NDI0NmFkYWZkYTcwOWM1M2M0MzNhZS5iaW5kUG9wdXAocG9wdXBfYTY2YzlhNzlmNTQ4NDBhNmEzM2RjYjI1MWMyNTUxMTIpCiAgICAgICAgOwoKICAgICAgICAKICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb2x5X2xpbmVfMDNmZTc2NzM5YTg4NDdhYThhOWNhNTc4ZDAzNDVmNTYgPSBMLnBvbHlsaW5lKAogICAgICAgICAgICAgICAgW1s2MC4xNjM1NDA5LCAyNC45MjQ3MTA4XSwgWzYwLjE2MzUwMjksIDI0LjkyNDYwNDhdXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjY2MwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiBmYWxzZSwgImZpbGxDb2xvciI6ICIjY2MwMDAwIiwgImZpbGxPcGFjaXR5IjogMC4yLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm5vQ2xpcCI6IGZhbHNlLCAib3BhY2l0eSI6IDEsICJzbW9vdGhGYWN0b3IiOiAxLjAsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogNX0KICAgICAgICAgICAgKS5hZGRUbyhtYXBfMGZiYzFiNzYxNzk0NGQ0NWI2NWM5YjkwNjgzZDQ0YjEpOwogICAgICAgIAogICAgCiAgICAgICAgdmFyIHBvcHVwXzI0MzcyZjNhMjdlMzQ4ODVhYTg0ZTI1OWY4ZDcxNTVjID0gTC5wb3B1cCh7Im1heFdpZHRoIjogIjEwMCUifSk7CgogICAgICAgIAogICAgICAgICAgICB2YXIgaHRtbF82MmIxN2ZmODE1ZTE0ZmI2OGZjNDVmYmZhNzllMjQxZCA9ICQoYDxkaXYgaWQ9Imh0bWxfNjJiMTdmZjgxNWUxNGZiNjhmYzQ1ZmJmYTc5ZTI0MWQiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjUuODwvZGl2PmApWzBdOwogICAgICAgICAgICBwb3B1cF8yNDM3MmYzYTI3ZTM0ODg1YWE4NGUyNTlmOGQ3MTU1Yy5zZXRDb250ZW50KGh0bWxfNjJiMTdmZjgxNWUxNGZiNjhmYzQ1ZmJmYTc5ZTI0MWQpOwogICAgICAgIAoKICAgICAgICBwb2x5X2xpbmVfMDNmZTc2NzM5YTg4NDdhYThhOWNhNTc4ZDAzNDVmNTYuYmluZFBvcHVwKHBvcHVwXzI0MzcyZjNhMjdlMzQ4ODVhYTg0ZTI1OWY4ZDcxNTVjKQogICAgICAgIDsKCiAgICAgICAgCiAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9seV9saW5lXzQ2NjcxMDZmYjY2NzQzYzhhMDRmM2UxYjM0ZWRmMTdkID0gTC5wb2x5bGluZSgKICAgICAgICAgICAgICAgIFtbNjAuMTYzNTAyOSwgMjQuOTI0NjA0OF0sIFs2MC4xNjM0NzQzLCAyNC45MjQ1MjI1XV0sCiAgICAgICAgICAgICAgICB7ImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLCAiY29sb3IiOiAiI2NjMDAwMCIsICJkYXNoQXJyYXkiOiBudWxsLCAiZGFzaE9mZnNldCI6IG51bGwsICJmaWxsIjogZmFsc2UsICJmaWxsQ29sb3IiOiAiI2NjMDAwMCIsICJmaWxsT3BhY2l0eSI6IDAuMiwgImZpbGxSdWxlIjogImV2ZW5vZGQiLCAibGluZUNhcCI6ICJyb3VuZCIsICJsaW5lSm9pbiI6ICJyb3VuZCIsICJub0NsaXAiOiBmYWxzZSwgIm9wYWNpdHkiOiAxLCAic21vb3RoRmFjdG9yIjogMS4wLCAic3Ryb2tlIjogdHJ1ZSwgIndlaWdodCI6IDV9CiAgICAgICAgICAgICkuYWRkVG8obWFwXzBmYmMxYjc2MTc5NDRkNDViNjVjOWI5MDY4M2Q0NGIxKTsKICAgICAgICAKICAgIAogICAgICAgIHZhciBwb3B1cF8zNGEyNGU3NDgwMDU0YWI0OTBkOWY0NDAxM2M5NGJkMiA9IEwucG9wdXAoeyJtYXhXaWR0aCI6ICIxMDAlIn0pOwoKICAgICAgICAKICAgICAgICAgICAgdmFyIGh0bWxfMjQxNzcyMWUzMjg1NDBhZTlhMzg1M2VhYmEyZjMyMzMgPSAkKGA8ZGl2IGlkPSJodG1sXzI0MTc3MjFlMzI4NTQwYWU5YTM4NTNlYWJhMmYzMjMzIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij40LjQ8L2Rpdj5gKVswXTsKICAgICAgICAgICAgcG9wdXBfMzRhMjRlNzQ4MDA1NGFiNDkwZDlmNDQwMTNjOTRiZDIuc2V0Q29udGVudChodG1sXzI0MTc3MjFlMzI4NTQwYWU5YTM4NTNlYWJhMmYzMjMzKTsKICAgICAgICAKCiAgICAgICAgcG9seV9saW5lXzQ2NjcxMDZmYjY2NzQzYzhhMDRmM2UxYjM0ZWRmMTdkLmJpbmRQb3B1cChwb3B1cF8zNGEyNGU3NDgwMDU0YWI0OTBkOWY0NDAxM2M5NGJkMikKICAgICAgICA7CgogICAgICAgIAogICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvbHlfbGluZV82MDNjMGE4ODViOTE0YjIwOTZkNDg4YjQzMDkwZDRiYiA9IEwucG9seWxpbmUoCiAgICAgICAgICAgICAgICBbWzYwLjE2MzQ3NDMsIDI0LjkyNDUyMjVdLCBbNjAuMTYzODEwMywgMjQuOTI0MDUxOF1dLAogICAgICAgICAgICAgICAgeyJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwgImNvbG9yIjogIiNjYzAwMDAiLCAiZGFzaEFycmF5IjogbnVsbCwgImRhc2hPZmZzZXQiOiBudWxsLCAiZmlsbCI6IGZhbHNlLCAiZmlsbENvbG9yIjogIiNjYzAwMDAiLCAiZmlsbE9wYWNpdHkiOiAwLjIsICJmaWxsUnVsZSI6ICJldmVub2RkIiwgImxpbmVDYXAiOiAicm91bmQiLCAibGluZUpvaW4iOiAicm91bmQiLCAibm9DbGlwIjogZmFsc2UsICJvcGFjaXR5IjogMSwgInNtb290aEZhY3RvciI6IDEuMCwgInN0cm9rZSI6IHRydWUsICJ3ZWlnaHQiOiA1fQogICAgICAgICAgICApLmFkZFRvKG1hcF8wZmJjMWI3NjE3OTQ0ZDQ1YjY1YzliOTA2ODNkNDRiMSk7CiAgICAgICAgCiAgICAKICAgICAgICB2YXIgcG9wdXBfODAwNzk4NzMyZWQ5NGY2MWFjNmNlZDY0ODQ3MGIwMmQgPSBMLnBvcHVwKHsibWF4V2lkdGgiOiAiMTAwJSJ9KTsKCiAgICAgICAgCiAgICAgICAgICAgIHZhciBodG1sXzA3OWY3MDc5ZjQ2YTRiNjY4NWMwODQ1Y2I4MGYyNzcyID0gJChgPGRpdiBpZD0iaHRtbF8wNzlmNzA3OWY0NmE0YjY2ODVjMDg0NWNiODBmMjc3MiIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+MzYuNDwvZGl2PmApWzBdOwogICAgICAgICAgICBwb3B1cF84MDA3OTg3MzJlZDk0ZjYxYWM2Y2VkNjQ4NDcwYjAyZC5zZXRDb250ZW50KGh0bWxfMDc5ZjcwNzlmNDZhNGI2Njg1YzA4NDVjYjgwZjI3NzIpOwogICAgICAgIAoKICAgICAgICBwb2x5X2xpbmVfNjAzYzBhODg1YjkxNGIyMDk2ZDQ4OGI0MzA5MGQ0YmIuYmluZFBvcHVwKHBvcHVwXzgwMDc5ODczMmVkOTRmNjFhYzZjZWQ2NDg0NzBiMDJkKQogICAgICAgIDsKCiAgICAgICAgCiAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9seV9saW5lX2FhMTgyOWQzYjFhMDQxYjliYjQzMTRlY2JjMjEyOWMyID0gTC5wb2x5bGluZSgKICAgICAgICAgICAgICAgIFtbNjAuMTYzODEwMywgMjQuOTI0MDUxOF0sIFs2MC4xNjM4MzUxLCAyNC45MjQwMTddXSwKICAgICAgICAgICAgICAgIHsiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsICJjb2xvciI6ICIjY2MwMDAwIiwgImRhc2hBcnJheSI6IG51bGwsICJkYXNoT2Zmc2V0IjogbnVsbCwgImZpbGwiOiBmYWxzZSwgImZpbGxDb2xvciI6ICIjY2MwMDAwIiwgImZpbGxPcGFjaXR5IjogMC4yLCAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsICJsaW5lQ2FwIjogInJvdW5kIiwgImxpbmVKb2luIjogInJvdW5kIiwgIm5vQ2xpcCI6IGZhbHNlLCAib3BhY2l0eSI6IDEsICJzbW9vdGhGYWN0b3IiOiAxLjAsICJzdHJva2UiOiB0cnVlLCAid2VpZ2h0IjogNX0KICAgICAgICAgICAgKS5hZGRUbyhtYXBfMGZiYzFiNzYxNzk0NGQ0NWI2NWM5YjkwNjgzZDQ0YjEpOwogICAgICAgIAogICAgCiAgICAgICAgdmFyIHBvcHVwX2E0YzM1ZWQxOWM0NTQwZjVhY2JjY2JkZjA0MzU5YWRlID0gTC5wb3B1cCh7Im1heFdpZHRoIjogIjEwMCUifSk7CgogICAgICAgIAogICAgICAgICAgICB2YXIgaHRtbF82NzA4OTZiMjk5ZTE0ZGJkOTgwMmQxYzY4Zjc0OGM0MiA9ICQoYDxkaXYgaWQ9Imh0bWxfNjcwODk2YjI5OWUxNGRiZDk4MDJkMWM2OGY3NDhjNDIiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPjIuNzwvZGl2PmApWzBdOwogICAgICAgICAgICBwb3B1cF9hNGMzNWVkMTljNDU0MGY1YWNiY2NiZGYwNDM1OWFkZS5zZXRDb250ZW50KGh0bWxfNjcwODk2YjI5OWUxNGRiZDk4MDJkMWM2OGY3NDhjNDIpOwogICAgICAgIAoKICAgICAgICBwb2x5X2xpbmVfYWExODI5ZDNiMWEwNDFiOWJiNDMxNGVjYmMyMTI5YzIuYmluZFBvcHVwKHBvcHVwX2E0YzM1ZWQxOWM0NTQwZjVhY2JjY2JkZjA0MzU5YWRlKQogICAgICAgIDsKCiAgICAgICAgCiAgICAKICAgIAogICAgICAgICAgICBtYXBfMGZiYzFiNzYxNzk0NGQ0NWI2NWM5YjkwNjgzZDQ0YjEuZml0Qm91bmRzKAogICAgICAgICAgICAgICAgW1s2MC4xNjM0NzQzLCAyNC45MjQwMTddLCBbNjAuMTY2ODg2NywgMjQuOTM2ODA3XV0sCiAgICAgICAgICAgICAgICB7fQogICAgICAgICAgICApOwogICAgICAgIAo8L3NjcmlwdD4= onload="this.contentDocument.open();this.contentDocument.write(atob(this.getAttribute('data-html')));this.contentDocument.close();" allowfullscreen webkitallowfullscreen mozallowfullscreen></iframe></div></div></div></div>
</div>
<div class="section" id="calculate-travel-times-from-one-to-many-locations">
<h2>Calculate travel times from one to many locations<a class="headerlink" href="#calculate-travel-times-from-one-to-many-locations" title="Permalink to this headline">¶</a></h2>
<p>When trying to understand the accessibility of a specific location, you
typically want to look at travel times between multiple locations
(one-to-many) or use isochrones (travel time contours).</p>
<ul class="simple">
<li><p>Let’s see how we can calculate travel times from the origin node, to
all other nodes in our graph using NetworkX function
<code class="docutils literal notranslate"><span class="pre">single_source_dijkstra_path_length()</span></code>:</p></li>
</ul>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Calculate walk travel times originating from one location</span>
<span class="n">walk_times</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_dijkstra_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;walk_t&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># What did we get?</span>
<span class="n">walk_times</span>

<span class="p">{</span><span class="mi">298372995</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
 <span class="mi">310042886</span><span class="p">:</span> <span class="mf">4.3</span><span class="p">,</span>
 <span class="mi">298372997</span><span class="p">:</span> <span class="mf">4.8</span><span class="p">,</span>
 <span class="mi">1377211668</span><span class="p">:</span> <span class="mf">9.1</span><span class="p">,</span>
 <span class="mi">298372992</span><span class="p">:</span> <span class="mf">10.1</span><span class="p">,</span>
 <span class="mi">298372994</span><span class="p">:</span> <span class="mf">10.5</span><span class="p">,</span>
 <span class="mi">298372999</span><span class="p">:</span> <span class="mf">14.6</span><span class="p">,</span>
 <span class="mi">298373001</span><span class="p">:</span> <span class="mf">15.0</span><span class="p">,</span>
 <span class="mi">298275980</span><span class="p">:</span> <span class="mf">20.4</span><span class="p">,</span>
 <span class="mi">1008235033</span><span class="p">:</span> <span class="mf">58.6</span><span class="p">,</span>
 <span class="mi">298275990</span><span class="p">:</span> <span class="mf">61.6</span><span class="p">,</span>
 <span class="mi">298275993</span><span class="p">:</span> <span class="mf">63.1</span><span class="p">,</span>
<span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As we can see, the result is a dictionary where we have the <strong>node_id</strong>
as keys and the <strong>travel time</strong> as values.</p>
<p>For visualizing this information, we need to join this data with the
nodes. For doing this, we can first convert the result to DataFrame and
then we can easily merge the information with the nodes GeoDataFrame.</p>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="c1"># Convert to DataFrame and add column names</span>
<span class="n">walk_times_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">walk_times</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="nb">list</span><span class="p">(</span><span class="n">walk_times</span><span class="o">.</span><span class="n">values</span><span class="p">())])</span><span class="o">.</span><span class="n">T</span>
<span class="n">walk_times_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;node_id&#39;</span><span class="p">,</span> <span class="s1">&#39;walk_t&#39;</span><span class="p">]</span>

<span class="c1"># What do we have now?</span>
<span class="n">walk_times_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>node_id</th>
      <th>walk_t</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2.983730e+08</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3.100429e+08</td>
      <td>4.3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2.983730e+08</td>
      <td>4.8</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1.377212e+09</td>
      <td>9.1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2.983730e+08</td>
      <td>10.1</td>
    </tr>
  </tbody>
</table>
</div></div></div>
<p>Great! Now we have the travel times <strong>from origin</strong> to all other nodes
in the graph.</p>
<ul class="simple">
<li><p>Let’s finally merge the data with the nodes GeoDataFrame and
visualize the results</p></li>
</ul>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check the nodes</span>
<span class="n">nodes</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>y</th>
      <th>x</th>
      <th>osmid</th>
      <th>highway</th>
      <th>ref</th>
      <th>geometry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>3216400385</th>
      <td>60.167552</td>
      <td>24.934005</td>
      <td>3216400385</td>
      <td>turning_circle</td>
      <td>NaN</td>
      <td>POINT (24.93400 60.16755)</td>
    </tr>
    <tr>
      <th>1372233731</th>
      <td>60.162290</td>
      <td>24.929274</td>
      <td>1372233731</td>
      <td>crossing</td>
      <td>NaN</td>
      <td>POINT (24.92927 60.16229)</td>
    </tr>
    <tr>
      <th>1005744134</th>
      <td>60.161622</td>
      <td>24.924423</td>
      <td>1005744134</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>POINT (24.92442 60.16162)</td>
    </tr>
    <tr>
      <th>319885318</th>
      <td>60.165062</td>
      <td>24.925501</td>
      <td>319885318</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>POINT (24.92550 60.16506)</td>
    </tr>
    <tr>
      <th>3216400394</th>
      <td>60.167662</td>
      <td>24.933920</td>
      <td>3216400394</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>POINT (24.93392 60.16766)</td>
    </tr>
  </tbody>
</table>
</div></div></div>
<p>As we can see, the <code class="docutils literal notranslate"><span class="pre">node_id</span></code> in the nodes GeoDataFrame can be found
from the <code class="docutils literal notranslate"><span class="pre">index</span></code> of the gdf as well as from the column <code class="docutils literal notranslate"><span class="pre">osmid</span></code>.</p>
<ul class="simple">
<li><p>Let’s merge these two datasets:</p></li>
</ul>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Merge the datasets</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">walk_times_df</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s1">&#39;osmid&#39;</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s1">&#39;node_id&#39;</span><span class="p">)</span>

<span class="c1"># Check</span>
<span class="n">nodes</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>y</th>
      <th>x</th>
      <th>osmid</th>
      <th>highway</th>
      <th>ref</th>
      <th>geometry</th>
      <th>node_id</th>
      <th>walk_t</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>60.167552</td>
      <td>24.934005</td>
      <td>3216400385</td>
      <td>turning_circle</td>
      <td>NaN</td>
      <td>POINT (24.93400 60.16755)</td>
      <td>3.216400e+09</td>
      <td>208.4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>60.162290</td>
      <td>24.929274</td>
      <td>1372233731</td>
      <td>crossing</td>
      <td>NaN</td>
      <td>POINT (24.92927 60.16229)</td>
      <td>1.372234e+09</td>
      <td>639.3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>60.161622</td>
      <td>24.924423</td>
      <td>1005744134</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>POINT (24.92442 60.16162)</td>
      <td>1.005744e+09</td>
      <td>775.7</td>
    </tr>
    <tr>
      <th>3</th>
      <td>60.165062</td>
      <td>24.925501</td>
      <td>319885318</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>POINT (24.92550 60.16506)</td>
      <td>3.198853e+08</td>
      <td>617.4</td>
    </tr>
    <tr>
      <th>4</th>
      <td>60.167662</td>
      <td>24.933920</td>
      <td>3216400394</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>POINT (24.93392 60.16766)</td>
      <td>3.216400e+09</td>
      <td>193.6</td>
    </tr>
  </tbody>
</table>
</div></div></div>
<p>Okay, now we have also the travel times associated for each node.</p>
<ul class="simple">
<li><p>Let’s visualize this:</p></li>
</ul>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline

<span class="c1"># Make a GeoDataFrame for the origin point so that we can visualize it</span>
<span class="n">orig</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">orig_x</span><span class="p">,</span> <span class="n">orig_y</span><span class="p">)]},</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;init&#39;</span><span class="p">:</span> <span class="s1">&#39;epsg:4326&#39;</span><span class="p">})</span>

<span class="c1"># Plot the results with edges and the origin point (green)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="s1">&#39;walk_t&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdYlBu&#39;</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="s1">&#39;natural_breaks&#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">orig</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>

<span class="c1"># Adjust axis</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="mf">24.92</span><span class="p">,</span> <span class="mf">24.945</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mf">60.160</span><span class="p">,</span> <span class="mf">60.170</span><span class="p">])</span>
</pre></div>
</div>
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>(60.16, 60.17)
</pre></div>
</div>
<img alt="../_images/spatial_network_analysis_src_18_2.png" src="../_images/spatial_network_analysis_src_18_2.png" />
</div>
<p>Okay, as we can see now we have quickly calculated the travel times for
each node in the graph using a single call.</p>
<p>If you would have for example a predefined grid, you could find the
nearest node for each grid centroid to produce a more matrix-like
result.</p>
<div class="section" id="alternative-approach-ego-graph">
<h3>Alternative approach - Ego graph<a class="headerlink" href="#alternative-approach-ego-graph" title="Permalink to this headline">¶</a></h3>
<p>Alternatively, it is possible to directly set a specific time limit and
restrict <strong>how long the graph is travelled</strong> from the origin, and return
that subgraph for the user.</p>
<ul class="simple">
<li><p>Let’s see an example:</p></li>
</ul>
<div class="jupyter_container docutils container">
<div class="code_cell highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Take a subgraph until 4 minutes by walking (240 seconds)</span>
<span class="n">subgraph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">ego_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">orig_node_id</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">240</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="s1">&#39;walk_t&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">ox</span><span class="o">.</span><span class="n">plot_graph</span><span class="p">(</span><span class="n">subgraph</span><span class="p">)</span>
</pre></div>
</div>
<img alt="../_images/spatial_network_analysis_src_19_0.png" src="../_images/spatial_network_analysis_src_19_0.png" />
</div>
<p>As we can see, with this approach we can retrieve a partial graph that
we could for example visualize with different colors, or e.g. subset the
extent of our accessibility analysis to cover only specific range from
the source.</p>
<script src="https://hypothes.is/embed.js" async> </script></div>
</div>
</div>


              </div>
              
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="spatial_interpolation.html" title="previous page">5. Spatial Interpolation</a>
    <a class='right-next' id="next-link" href="spatial_regression.html" title="next page">7. Spatial Regression</a>

              </div>
              
          </main>
          

      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright 2020, Henrikki Tenkanen. Demonstration material for Aalto University.<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>